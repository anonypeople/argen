<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\daniel.rodriguez\IdeaProjects\biorimp\resources\systems\JF_DATASET-20\src\DatasetUtilities.java"><comment type="block">/* ===========================================================
 * JFreeChart : a free chart library for the Java(tm) platform
 * ===========================================================
 *
 * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.
 *
 * Project Info:  http://www.jfree.org/jfreechart/index.html
 *
 * This library is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public License as published by 
 * the Free Software Foundation; either version 2.1 of the License, or 
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 
 * USA.  
 *
 * [Java is a trademark or registered trademark of Sun Microsystems, Inc. 
 * in the United States and other countries.]
 *
 * ---------------------
 * DatasetUtilities.java
 * ---------------------
 * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.
 *
 * Original Author:  David Gilbert (for Object Refinery Limited);
 * Contributor(s):   Andrzej Porebski (bug fix);
 *                   Jonathan Nash (bug fix);
 *                   Richard Atkinson;
 *                   Andreas Schroeder;
 *
 * Changes (from 18-Sep-2001)
 * --------------------------
 * 18-Sep-2001 : Added standard header and fixed DOS encoding problem (DG);
 * 22-Oct-2001 : Renamed DataSource.java --&gt; Dataset.java etc. (DG);
 * 15-Nov-2001 : Moved to package com.jrefinery.data.* in the JCommon class 
 *               library (DG);
 *               Changed to handle null values from datasets (DG);
 *               Bug fix (thanks to Andrzej Porebski) - initial value now set 
 *               to positive or negative infinity when iterating (DG);
 * 22-Nov-2001 : Datasets with containing no data now return null for min and 
 *               max calculations (DG);
 * 13-Dec-2001 : Extended to handle HighLowDataset and IntervalXYDataset (DG);
 * 15-Feb-2002 : Added getMinimumStackedRangeValue() and 
 *               getMaximumStackedRangeValue() (DG);
 * 28-Feb-2002 : Renamed Datasets.java --&gt; DatasetUtilities.java (DG);
 * 18-Mar-2002 : Fixed bug in min/max domain calculation for datasets that 
 *               implement the CategoryDataset interface AND the XYDataset 
 *               interface at the same time.  Thanks to Jonathan Nash for the 
 *               fix (DG);
 * 23-Apr-2002 : Added getDomainExtent() and getRangeExtent() methods (DG);
 * 13-Jun-2002 : Modified range measurements to handle 
 *               IntervalCategoryDataset (DG);
 * 12-Jul-2002 : Method name change in DomainInfo interface (DG);
 * 30-Jul-2002 : Added pie dataset summation method (DG);
 * 01-Oct-2002 : Added a method for constructing an XYDataset from a Function2D
 *               instance (DG);
 * 24-Oct-2002 : Amendments required following changes to the CategoryDataset 
 *               interface (DG);
 * 18-Nov-2002 : Changed CategoryDataset to TableDataset (DG);
 * 04-Mar-2003 : Added isEmpty(XYDataset) method (DG);
 * 05-Mar-2003 : Added a method for creating a CategoryDataset from a 
 *               KeyedValues instance (DG);
 * 15-May-2003 : Renamed isEmpty --&gt; isEmptyOrNull (DG);
 * 25-Jun-2003 : Added limitPieDataset methods (RA);
 * 26-Jun-2003 : Modified getDomainExtent() method to accept null datasets (DG);
 * 27-Jul-2003 : Added getStackedRangeExtent(TableXYDataset data) (RA);
 * 18-Aug-2003 : getStackedRangeExtent(TableXYDataset data) now handles null 
 *               values (RA);
 * 02-Sep-2003 : Added method to check for null or empty PieDataset (DG);
 * 18-Sep-2003 : Fix for bug 803660 (getMaximumRangeValue for 
 *               CategoryDataset) (DG);
 * 20-Oct-2003 : Added getCumulativeRangeExtent() method (DG);
 * 09-Jan-2003 : Added argument checking code to the createCategoryDataset() 
 *               method (DG);
 * 23-Mar-2004 : Fixed bug in getMaximumStackedRangeValue() method (DG);
 * 31-Mar-2004 : Exposed the extent iteration algorithms to use one of them and 
 *               applied noninstantiation pattern (AS);
 * 11-May-2004 : Renamed getPieDatasetTotal --&gt; calculatePieDatasetTotal (DG);
 * 15-Jul-2004 : Switched getX() with getXValue() and getY() with getYValue();
 * 24-Aug-2004 : Added argument checks to createCategoryDataset() method (DG);
 * 04-Oct-2004 : Renamed ArrayUtils --&gt; ArrayUtilities (DG);
 * 06-Oct-2004 : Renamed findDomainExtent() --&gt; findDomainBounds(),
 *               findRangeExtent() --&gt; findRangeBounds() (DG);
 * 07-Jan-2005 : Renamed findStackedRangeExtent() --&gt; findStackedRangeBounds(),
 *               findCumulativeRangeExtent() --&gt; findCumulativeRangeBounds(),
 *               iterateXYRangeExtent() --&gt; iterateXYRangeBounds(), 
 *               removed deprecated methods (DG);
 * 03-Feb-2005 : The findStackedRangeBounds() methods now return null for 
 *               empty datasets (DG);
 * 03-Mar-2005 : Moved createNumberArray() and createNumberArray2D() methods
 *               from DatasetUtilities --&gt; DataUtilities (DG);
 * 22-Sep-2005 : Added new findStackedRangeBounds() method that takes base
 *               argument (DG);
 * ------------- JFREECHART 1.0.x ---------------------------------------------
 * 15-Mar-2007 : Added calculateStackTotal() method (DG);
 * 
 */</comment>

<package>package <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>general</name></name>;</package>

<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Iterator</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>

<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>DomainInfo</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>KeyToGroupMap</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>KeyedValues</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>Range</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>RangeInfo</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>category</name>.<name>CategoryDataset</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>category</name>.<name>DefaultCategoryDataset</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>category</name>.<name>IntervalCategoryDataset</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>function</name>.<name>Function2D</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>xy</name>.<name>IntervalXYDataset</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>xy</name>.<name>OHLCDataset</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>xy</name>.<name>TableXYDataset</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>xy</name>.<name>XYDataset</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>xy</name>.<name>XYSeries</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>xy</name>.<name>XYSeriesCollection</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>util</name>.<name>ArrayUtilities</name></name>;</import>

<comment type="javadoc">/**
 * A collection of useful static methods relating to datasets.
 */</comment>
<class><specifier>public</specifier> <specifier>final</specifier> class <name>DatasetUtilities</name> <block>{
    
    <comment type="javadoc">/**
     * Private constructor for non-instanceability.
     */</comment>
    <constructor><specifier>private</specifier> <name>DatasetUtilities</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// now try to instantiate this ;-)</comment>
    }</block></constructor>

    <comment type="javadoc">/**
     * Calculates the total of all the values in a {@link PieDataset}.  If 
     * the dataset contains negative or &lt;code&gt;null&lt;/code&gt; values, they are 
     * ignored. 
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return The total.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>double</name></type> <name>calculatePieDatasetTotal</name><parameter_list>(<param><decl><type><name>PieDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>List</name></type> <name>keys</name> =<init> <expr><call><name><name>dataset</name>.<name>getKeys</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>totalValue</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Iterator</name></type> <name>iterator</name> =<init> <expr><call><name><name>keys</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iterator</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>Comparable</name></type> <name>current</name> =<init> <expr>(<name>Comparable</name>) <call><name><name>iterator</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>current</name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Number</name></type> <name>value</name> =<init> <expr><call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>double</name></type> <name>v</name> =<init> <expr>0.0</expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>value</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>v</name> = <call><name><name>value</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>v</name> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>totalValue</name> = <name>totalValue</name> + <name>v</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></while>
        <return>return <expr><name>totalValue</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a pie dataset from a table dataset by taking all the values
     * for a single row.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param rowKey  the row key.
     *
     * @return A pie dataset.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>PieDataset</name></type> <name>createPieDatasetForRow</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>, 
                                                    <param><decl><type><name>Comparable</name></type> <name>rowKey</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>row</name> =<init> <expr><call><name><name>dataset</name>.<name>getRowIndex</name></name><argument_list>(<argument><expr><name>rowKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>createPieDatasetForRow</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a pie dataset from a table dataset by taking all the values
     * for a single row.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param row  the row (zero-based index).
     *
     * @return A pie dataset.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>PieDataset</name></type> <name>createPieDatasetForRow</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>, 
                                                    <param><decl><type><name>int</name></type> <name>row</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>DefaultPieDataset</name></type> <name>result</name> =<init> <expr>new <call><name>DefaultPieDataset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getColumnCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>current</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>current</name> &lt; <name>columnCount</name></expr>;</condition> <incr><expr><name>current</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>Comparable</name></type> <name>columnKey</name> =<init> <expr><call><name><name>dataset</name>.<name>getColumnKey</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>result</name>.<name>setValue</name></name><argument_list>(<argument><expr><name>columnKey</name></expr></argument>, <argument><expr><call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a pie dataset from a table dataset by taking all the values
     * for a single column.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param columnKey  the column key.
     *
     * @return A pie dataset.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>PieDataset</name></type> <name>createPieDatasetForColumn</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>,
                                                       <param><decl><type><name>Comparable</name></type> <name>columnKey</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>column</name> =<init> <expr><call><name><name>dataset</name>.<name>getColumnIndex</name></name><argument_list>(<argument><expr><name>columnKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>createPieDatasetForColumn</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a pie dataset from a {@link CategoryDataset} by taking all the 
     * values for a single column.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param column  the column (zero-based index).
     *
     * @return A pie dataset.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>PieDataset</name></type> <name>createPieDatasetForColumn</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>, 
                                                       <param><decl><type><name>int</name></type> <name>column</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>DefaultPieDataset</name></type> <name>result</name> =<init> <expr>new <call><name>DefaultPieDataset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rowCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>rowCount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>Comparable</name></type> <name>rowKey</name> =<init> <expr><call><name><name>dataset</name>.<name>getRowKey</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>result</name>.<name>setValue</name></name><argument_list>(<argument><expr><name>rowKey</name></expr></argument>, <argument><expr><call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a new pie dataset based on the supplied dataset, but modified
     * by aggregating all the low value items (those whose value is lower
     * than the &lt;code&gt;percentThreshold&lt;/code&gt;) into a single item with the
     * key "Other".
     *
     * @param source  the source dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param key  a new key for the aggregated items (&lt;code&gt;null&lt;/code&gt; not
     *             permitted).
     * @param minimumPercent  the percent threshold.
     * 
     * @return The pie dataset with (possibly) aggregated items.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>PieDataset</name></type> <name>createConsolidatedPieDataset</name><parameter_list>(<param><decl><type><name>PieDataset</name></type> <name>source</name></decl></param>, 
                                                          <param><decl><type><name>Comparable</name></type> <name>key</name></decl></param>,
                                                          <param><decl><type><name>double</name></type> <name>minimumPercent</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>DatasetUtilities</name>.<name>createConsolidatedPieDataset</name></name><argument_list>(
            <argument><expr><name>source</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>minimumPercent</name></expr></argument>, <argument><expr>2</expr></argument>
        )</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a new pie dataset based on the supplied dataset, but modified 
     * by aggregating all the low value items (those whose value is lower 
     * than the &lt;code&gt;percentThreshold&lt;/code&gt;) into a single item.  The 
     * aggregated items are assigned the specified key.  Aggregation only 
     * occurs if there are at least &lt;code&gt;minItems&lt;/code&gt; items to aggregate.
     *
     * @param source  the source dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param key  the key to represent the aggregated items.
     * @param minimumPercent  the percent threshold (ten percent is 0.10).
     * @param minItems  only aggregate low values if there are at least this 
     *                  many.
     * 
     * @return The pie dataset with (possibly) aggregated items.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>PieDataset</name></type> <name>createConsolidatedPieDataset</name><parameter_list>(<param><decl><type><name>PieDataset</name></type> <name>source</name></decl></param>,
                                                          <param><decl><type><name>Comparable</name></type> <name>key</name></decl></param>,
                                                          <param><decl><type><name>double</name></type> <name>minimumPercent</name></decl></param>,
                                                          <param><decl><type><name>int</name></type> <name>minItems</name></decl></param>)</parameter_list> <block>{
        
        <decl_stmt><decl><type><name>DefaultPieDataset</name></type> <name>result</name> =<init> <expr>new <call><name>DefaultPieDataset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>total</name> =<init> <expr><call><name><name>DatasetUtilities</name>.<name>calculatePieDatasetTotal</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">//  Iterate and find all keys below threshold percentThreshold</comment>
        <decl_stmt><decl><type><name>List</name></type> <name>keys</name> =<init> <expr><call><name><name>source</name>.<name>getKeys</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ArrayList</name></type> <name>otherKeys</name> =<init> <expr>new <call><name>ArrayList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Iterator</name></type> <name>iterator</name> =<init> <expr><call><name><name>keys</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iterator</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>Comparable</name></type> <name>currentKey</name> =<init> <expr>(<name>Comparable</name>) <call><name><name>iterator</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Number</name></type> <name>dataValue</name> =<init> <expr><call><name><name>source</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>dataValue</name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>double</name></type> <name>value</name> =<init> <expr><call><name><name>dataValue</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>value</name> / <name>total</name> &lt; <name>minimumPercent</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>otherKeys</name>.<name>add</name></name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></while>

        <comment type="line">//  Create new dataset with keys above threshold percentThreshold</comment>
        <expr_stmt><expr><name>iterator</name> = <call><name><name>keys</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>otherValue</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iterator</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>Comparable</name></type> <name>currentKey</name> =<init> <expr>(<name>Comparable</name>) <call><name><name>iterator</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Number</name></type> <name>dataValue</name> =<init> <expr><call><name><name>source</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>dataValue</name> != <name>null</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name><name>otherKeys</name>.<name>contains</name></name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>)</argument_list></call> 
                    &amp;&amp; <call><name><name>otherKeys</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt;= <name>minItems</name></expr>)</condition><then> <block>{
                    <comment type="line">//  Do not add key to dataset</comment>
                    <expr_stmt><expr><name>otherValue</name> += <call><name><name>dataValue</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <comment type="line">//  Add key to dataset</comment>
                    <expr_stmt><expr><call><name><name>result</name>.<name>setValue</name></name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>, <argument><expr><name>dataValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then></if>
        }</block></while>
        <comment type="line">//  Add other category if applicable</comment>
        <if>if <condition>(<expr><call><name><name>otherKeys</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt;= <name>minItems</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>result</name>.<name>setValue</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>otherValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Creates a {@link CategoryDataset} that contains a copy of the data in an
     * array (instances of &lt;code&gt;Double&lt;/code&gt; are created to represent the 
     * data items).
     * &lt;p&gt;
     * Row and column keys are created by appending 0, 1, 2, ... to the 
     * supplied prefixes.
     *
     * @param rowKeyPrefix  the row key prefix.
     * @param columnKeyPrefix  the column key prefix.
     * @param data  the data.
     *
     * @return The dataset.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>CategoryDataset</name></type> <name>createCategoryDataset</name><parameter_list>(<param><decl><type><name>String</name></type> <name>rowKeyPrefix</name></decl></param>,
                                                        <param><decl><type><name>String</name></type> <name>columnKeyPrefix</name></decl></param>,
                                                        <param><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>data</name></decl></param>)</parameter_list> <block>{

        <decl_stmt><decl><type><name>DefaultCategoryDataset</name></type> <name>result</name> =<init> <expr>new <call><name>DefaultCategoryDataset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>r</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>r</name> &lt; <name><name>data</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>r</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>rowKey</name> =<init> <expr><name>rowKeyPrefix</name> + (<name>r</name> + 1)</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>c</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>c</name> &lt; <name><name>data</name><index>[<expr><name>r</name></expr>]</index></name>.<name>length</name></expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>columnKey</name> =<init> <expr><name>columnKeyPrefix</name> + (<name>c</name> + 1)</expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>result</name>.<name>addValue</name></name><argument_list>(<argument><expr>new <call><name>Double</name><argument_list>(<argument><expr><name><name>data</name><index>[<expr><name>r</name></expr>]</index><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rowKey</name></expr></argument>, <argument><expr><name>columnKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>

    }</block></function>

    <comment type="javadoc">/**
     * Creates a {@link CategoryDataset} that contains a copy of the data in 
     * an array.
     * &lt;p&gt;
     * Row and column keys are created by appending 0, 1, 2, ... to the 
     * supplied prefixes.
     *
     * @param rowKeyPrefix  the row key prefix.
     * @param columnKeyPrefix  the column key prefix.
     * @param data  the data.
     *
     * @return The dataset.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>CategoryDataset</name></type> <name>createCategoryDataset</name><parameter_list>(<param><decl><type><name>String</name></type> <name>rowKeyPrefix</name></decl></param>,
                                                        <param><decl><type><name>String</name></type> <name>columnKeyPrefix</name></decl></param>,
                                                        <param><decl><type><name><name>Number</name><index>[]</index><index>[]</index></name></type> <name>data</name></decl></param>)</parameter_list> <block>{

        <decl_stmt><decl><type><name>DefaultCategoryDataset</name></type> <name>result</name> =<init> <expr>new <call><name>DefaultCategoryDataset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>r</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>r</name> &lt; <name><name>data</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>r</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>rowKey</name> =<init> <expr><name>rowKeyPrefix</name> + (<name>r</name> + 1)</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>c</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>c</name> &lt; <name><name>data</name><index>[<expr><name>r</name></expr>]</index></name>.<name>length</name></expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>columnKey</name> =<init> <expr><name>columnKeyPrefix</name> + (<name>c</name> + 1)</expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>result</name>.<name>addValue</name></name><argument_list>(<argument><expr><name><name>data</name><index>[<expr><name>r</name></expr>]</index><index>[<expr><name>c</name></expr>]</index></name></expr></argument>, <argument><expr><name>rowKey</name></expr></argument>, <argument><expr><name>columnKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>

    }</block></function>

    <comment type="javadoc">/**
     * Creates a {@link CategoryDataset} that contains a copy of the data in 
     * an array (instances of &lt;code&gt;Double&lt;/code&gt; are created to represent the 
     * data items).
     * &lt;p&gt;
     * Row and column keys are taken from the supplied arrays.
     *
     * @param rowKeys  the row keys (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param columnKeys  the column keys (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param data  the data.
     *
     * @return The dataset.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>CategoryDataset</name></type> <name>createCategoryDataset</name><parameter_list>(<param><decl><type><name><name>Comparable</name><index>[]</index></name></type> <name>rowKeys</name></decl></param>,
                                                        <param><decl><type><name><name>Comparable</name><index>[]</index></name></type> <name>columnKeys</name></decl></param>,
                                                        <param><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>data</name></decl></param>)</parameter_list> <block>{

        <comment type="line">// check arguments...</comment>
        <if>if <condition>(<expr><name>rowKeys</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'rowKeys' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>columnKeys</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'columnKeys' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>ArrayUtilities</name>.<name>hasDuplicateItems</name></name><argument_list>(<argument><expr><name>rowKeys</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Duplicate items in 'rowKeys'."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>ArrayUtilities</name>.<name>hasDuplicateItems</name></name><argument_list>(<argument><expr><name>columnKeys</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(
                <argument><expr>"Duplicate items in 'columnKeys'."</expr></argument>
            )</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>rowKeys</name>.<name>length</name></name> != <name><name>data</name>.<name>length</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(
                <argument><expr>"The number of row keys does not match the number of rows in "
                + "the data array."</expr></argument>
            )</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>r</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>r</name> &lt; <name><name>data</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>r</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>columnCount</name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>r</name></expr>]</index></name>.<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <if>if <condition>(<expr><name><name>columnKeys</name>.<name>length</name></name> != <name>columnCount</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(
                <argument><expr>"The number of column keys does not match the number of "
                + "columns in the data array."</expr></argument>
            )</argument_list></call></expr>;</throw>
        }</block></then></if>
        
        <comment type="line">// now do the work...</comment>
        <decl_stmt><decl><type><name>DefaultCategoryDataset</name></type> <name>result</name> =<init> <expr>new <call><name>DefaultCategoryDataset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>r</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>r</name> &lt; <name><name>data</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>r</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>Comparable</name></type> <name>rowKey</name> =<init> <expr><name><name>rowKeys</name><index>[<expr><name>r</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>c</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>c</name> &lt; <name><name>data</name><index>[<expr><name>r</name></expr>]</index></name>.<name>length</name></expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>Comparable</name></type> <name>columnKey</name> =<init> <expr><name><name>columnKeys</name><index>[<expr><name>c</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>result</name>.<name>addValue</name></name><argument_list>(<argument><expr>new <call><name>Double</name><argument_list>(<argument><expr><name><name>data</name><index>[<expr><name>r</name></expr>]</index><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rowKey</name></expr></argument>, <argument><expr><name>columnKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>

    }</block></function>

    <comment type="javadoc">/**
     * Creates a {@link CategoryDataset} by copying the data from the supplied 
     * {@link KeyedValues} instance.
     *
     * @param rowKey  the row key (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param rowData  the row data (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return A dataset.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>CategoryDataset</name></type> <name>createCategoryDataset</name><parameter_list>(<param><decl><type><name>Comparable</name></type> <name>rowKey</name></decl></param>, 
                                                        <param><decl><type><name>KeyedValues</name></type> <name>rowData</name></decl></param>)</parameter_list> <block>{

        <if>if <condition>(<expr><name>rowKey</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'rowKey' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>rowData</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'rowData' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>DefaultCategoryDataset</name></type> <name>result</name> =<init> <expr>new <call><name>DefaultCategoryDataset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>rowData</name>.<name>getItemCount</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name><name>result</name>.<name>addValue</name></name><argument_list>(<argument><expr><call><name><name>rowData</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rowKey</name></expr></argument>, <argument><expr><call><name><name>rowData</name>.<name>getKey</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>result</name></expr>;</return>

    }</block></function>

    <comment type="javadoc">/**
     * Creates an {@link XYDataset} by sampling the specified function over a 
     * fixed range.
     *
     * @param f  the function (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param start  the start value for the range.
     * @param end  the end value for the range.
     * @param samples  the number of sample points (must be &gt; 1).
     * @param seriesKey  the key to give the resulting series 
     *                   (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return A dataset.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>XYDataset</name></type> <name>sampleFunction2D</name><parameter_list>(<param><decl><type><name>Function2D</name></type> <name>f</name></decl></param>, 
                                             <param><decl><type><name>double</name></type> <name>start</name></decl></param>, 
                                             <param><decl><type><name>double</name></type> <name>end</name></decl></param>, 
                                             <param><decl><type><name>int</name></type> <name>samples</name></decl></param>,
                                             <param><decl><type><name>Comparable</name></type> <name>seriesKey</name></decl></param>)</parameter_list> <block>{

        <if>if <condition>(<expr><name>f</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'f' argument."</expr></argument>)</argument_list></call></expr>;</throw>   
        }</block></then></if>
        <if>if <condition>(<expr><name>seriesKey</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'seriesKey' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>start</name> &gt;= <name>end</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Requires 'start' &lt; 'end'."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>samples</name> &lt; 2</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Requires 'samples' &gt; 1"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <decl_stmt><decl><type><name>XYSeries</name></type> <name>series</name> =<init> <expr>new <call><name>XYSeries</name><argument_list>(<argument><expr><name>seriesKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>step</name> =<init> <expr>(<name>end</name> - <name>start</name>) / <name>samples</name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>samples</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>x</name> =<init> <expr><name>start</name> + (<name>step</name> * <name>i</name>)</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>series</name>.<name>add</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call><name><name>f</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <decl_stmt><decl><type><name>XYSeriesCollection</name></type> <name>collection</name> =<init> <expr>new <call><name>XYSeriesCollection</name><argument_list>(<argument><expr><name>series</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>collection</name></expr>;</return>

    }</block></function>

    <comment type="javadoc">/**
     * Returns &lt;code&gt;true&lt;/code&gt; if the dataset is empty (or &lt;code&gt;null&lt;/code&gt;),
     * and &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; permitted).
     *
     * @return A boolean.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isEmptyOrNull</name><parameter_list>(<param><decl><type><name>PieDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{

        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr>true</expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name>itemCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getItemCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>itemCount</name> == 0</expr>)</condition><then> <block>{
            <return>return <expr>true</expr>;</return>
        }</block></then></if>

        <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>itemCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>Number</name></type> <name>y</name> =<init> <expr><call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>y</name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>double</name></type> <name>yy</name> =<init> <expr><call><name><name>y</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>yy</name> &gt; 0.0</expr>)</condition><then> <block>{
                    <return>return <expr>false</expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block></for>

        <return>return <expr>true</expr>;</return>

    }</block></function>

    <comment type="javadoc">/**
     * Returns &lt;code&gt;true&lt;/code&gt; if the dataset is empty (or &lt;code&gt;null&lt;/code&gt;),
     * and &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; permitted).
     *
     * @return A boolean.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isEmptyOrNull</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{

        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr>true</expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name>rowCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getColumnCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>rowCount</name> == 0 || <name>columnCount</name> == 0</expr>)</condition><then> <block>{
            <return>return <expr>true</expr>;</return>
        }</block></then></if>

        <for>for (<init><decl><type><name>int</name></type> <name>r</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>r</name> &lt; <name>rowCount</name></expr>;</condition> <incr><expr><name>r</name>++</expr></incr>) <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>c</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>c</name> &lt; <name>columnCount</name></expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                    <return>return <expr>false</expr>;</return>
                }</block></then></if>

            }</block></for>
        }</block></for>

        <return>return <expr>true</expr>;</return>

    }</block></function>

    <comment type="javadoc">/**
     * Returns &lt;code&gt;true&lt;/code&gt; if the dataset is empty (or &lt;code&gt;null&lt;/code&gt;),
     * and &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; permitted).
     *
     * @return A boolean.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isEmptyOrNull</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>dataset</name> != <name>null</name></expr>)</condition><then> <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>s</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>s</name> &lt; <call><name><name>dataset</name>.<name>getSeriesCount</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>s</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><call><name><name>dataset</name>.<name>getItemCount</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
                    <return>return <expr>false</expr>;</return>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the range of values in the domain (x-values) of a dataset.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return The range of values (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findDomainBounds</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>findDomainBounds</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the range of values in the domain (x-values) of a dataset.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param includeInterval  determines whether or not the x-interval is taken
     *                         into account (only applies if the dataset is an
     *                         {@link IntervalXYDataset}).
     *
     * @return The range of values (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findDomainBounds</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>, 
                                         <param><decl><type><name>boolean</name></type> <name>includeInterval</name></decl></param>)</parameter_list> <block>{

        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <decl_stmt><decl><type><name>Range</name></type> <name>result</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <comment type="line">// if the dataset implements DomainInfo, life is easier</comment>
        <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>DomainInfo</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>DomainInfo</name></type> <name>info</name> =<init> <expr>(<name>DomainInfo</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>result</name> = <call><name><name>info</name>.<name>getDomainBounds</name></name><argument_list>(<argument><expr><name>includeInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>result</name> = <call><name>iterateDomainBounds</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr><name>includeInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>result</name></expr>;</return>
        
    }</block></function>

    <comment type="javadoc">/**
     * Iterates over the items in an {@link XYDataset} to find
     * the range of x-values. 
     *  
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * 
     * @return The range (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>iterateDomainBounds</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>iterateDomainBounds</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Iterates over the items in an {@link XYDataset} to find
     * the range of x-values. 
     *  
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param includeInterval  a flag that determines, for an IntervalXYDataset,
     *                         whether the x-interval or just the x-value is 
     *                         used to determine the overall range.
     *   
     * @return The range (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>iterateDomainBounds</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>, 
                                            <param><decl><type><name>boolean</name></type> <name>includeInterval</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>   
        }</block></then></if>
        <decl_stmt><decl><type><name>double</name></type> <name>minimum</name> =<init> <expr><name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>maximum</name> =<init> <expr><name><name>Double</name>.<name>NEGATIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getSeriesCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>lvalue</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>uvalue</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>includeInterval</name> &amp;&amp; <name>dataset</name> <name>instanceof</name> <name>IntervalXYDataset</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>IntervalXYDataset</name></type> <name>intervalXYData</name> =<init> <expr>(<name>IntervalXYDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>itemCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getItemCount</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>itemCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>lvalue</name> = <call><name><name>intervalXYData</name>.<name>getStartXValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uvalue</name> = <call><name><name>intervalXYData</name>.<name>getEndXValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>minimum</name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>lvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>maximum</name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>maximum</name></expr></argument>, <argument><expr><name>uvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></for>
        }</block></then>
        <else>else <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>itemCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getItemCount</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>itemCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>lvalue</name> = <call><name><name>dataset</name>.<name>getXValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uvalue</name> = <name>lvalue</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>minimum</name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>lvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>maximum</name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>maximum</name></expr></argument>, <argument><expr><name>uvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></for>
        }</block></else></if>
        <if>if <condition>(<expr><name>minimum</name> &gt; <name>maximum</name></expr>)</condition><then> <block>{
            <return>return <expr><name>null</name></expr>;</return>
        }</block></then>
        <else>else <block>{
            <return>return <expr>new <call><name>Range</name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>
    
    <comment type="javadoc">/**
     * Returns the range of values in the range for the dataset.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return The range (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findRangeBounds</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>findRangeBounds</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
    
    <comment type="javadoc">/**
     * Returns the range of values in the range for the dataset.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param includeInterval  a flag that determines whether or not the
     *                         y-interval is taken into account.
     * 
     * @return The range (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findRangeBounds</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>, 
                                        <param><decl><type><name>boolean</name></type> <name>includeInterval</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>Range</name></type> <name>result</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>RangeInfo</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>RangeInfo</name></type> <name>info</name> =<init> <expr>(<name>RangeInfo</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>result</name> = <call><name><name>info</name>.<name>getRangeBounds</name></name><argument_list>(<argument><expr><name>includeInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>result</name> = <call><name>iterateCategoryRangeBounds</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr><name>includeInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>
    
    <comment type="javadoc">/**
     * Returns the range of values in the range for the dataset.  This method
     * is the partner for the {@link #findDomainBounds(XYDataset)} method.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return The range (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findRangeBounds</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>findRangeBounds</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
    
    <comment type="javadoc">/**
     * Returns the range of values in the range for the dataset.  This method
     * is the partner for the {@link #findDomainBounds(XYDataset)} method.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param includeInterval  a flag that determines whether or not the
     *                         y-interval is taken into account.
     * 
     *
     * @return The range (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findRangeBounds</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>, 
                                        <param><decl><type><name>boolean</name></type> <name>includeInterval</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>Range</name></type> <name>result</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>RangeInfo</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>RangeInfo</name></type> <name>info</name> =<init> <expr>(<name>RangeInfo</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>result</name> = <call><name><name>info</name>.<name>getRangeBounds</name></name><argument_list>(<argument><expr><name>includeInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>result</name> = <call><name>iterateXYRangeBounds</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>
    
    <comment type="javadoc">/**
     * Iterates over the data item of the category dataset to find
     * the range bounds.
     * 
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param includeInterval  a flag that determines whether or not the
     *                         y-interval is taken into account.
     * 
     * @return The range (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>iterateCategoryRangeBounds</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>, 
            <param><decl><type><name>boolean</name></type> <name>includeInterval</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>double</name></type> <name>minimum</name> =<init> <expr><name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>maximum</name> =<init> <expr><name><name>Double</name>.<name>NEGATIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>interval</name> =<init> <expr><name>includeInterval</name> 
                           &amp;&amp; <name>dataset</name> <name>instanceof</name> <name>IntervalCategoryDataset</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rowCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getColumnCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>row</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>row</name> &lt; <name>rowCount</name></expr>;</condition> <incr><expr><name>row</name>++</expr></incr>) <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>column</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>column</name> &lt; <name>columnCount</name></expr>;</condition> <incr><expr><name>column</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>Number</name></type> <name>lvalue</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Number</name></type> <name>uvalue</name></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>interval</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>IntervalCategoryDataset</name></type> <name>icd</name> 
                        =<init> <expr>(<name>IntervalCategoryDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>lvalue</name> = <call><name><name>icd</name>.<name>getStartValue</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uvalue</name> = <call><name><name>icd</name>.<name>getEndValue</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><name>lvalue</name> = <call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uvalue</name> = <name>lvalue</name></expr>;</expr_stmt>
                }</block></else></if>
                <if>if <condition>(<expr><name>lvalue</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>minimum</name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><call><name><name>lvalue</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>uvalue</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>maximum</name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>maximum</name></expr></argument>, <argument><expr><call><name><name>uvalue</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></for>
        <if>if <condition>(<expr><name>minimum</name> == <name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr>)</condition><then> <block>{
            <return>return <expr><name>null</name></expr>;</return>
        }</block></then>
        <else>else <block>{
            <return>return <expr>new <call><name>Range</name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>
    
    <comment type="javadoc">/**
     * Iterates over the data item of the xy dataset to find
     * the range bounds.
     * 
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * 
     * @return The range (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>iterateXYRangeBounds</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>double</name></type> <name>minimum</name> =<init> <expr><name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>maximum</name> =<init> <expr><name><name>Double</name>.<name>NEGATIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getSeriesCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>itemCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getItemCount</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>itemCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>double</name></type> <name>lvalue</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>double</name></type> <name>uvalue</name></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>IntervalXYDataset</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>IntervalXYDataset</name></type> <name>intervalXYData</name> 
                        =<init> <expr>(<name>IntervalXYDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>lvalue</name> = <call><name><name>intervalXYData</name>.<name>getStartYValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uvalue</name> = <call><name><name>intervalXYData</name>.<name>getEndYValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>OHLCDataset</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>OHLCDataset</name></type> <name>highLowData</name> =<init> <expr>(<name>OHLCDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>lvalue</name> = <call><name><name>highLowData</name>.<name>getLowValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uvalue</name> = <call><name><name>highLowData</name>.<name>getHighValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><name>lvalue</name> = <call><name><name>dataset</name>.<name>getYValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uvalue</name> = <name>lvalue</name></expr>;</expr_stmt>
                }</block></else></if></else></if>
                <if>if <condition>(<expr>!<call><name><name>Double</name>.<name>isNaN</name></name><argument_list>(<argument><expr><name>lvalue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>minimum</name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>lvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr>!<call><name><name>Double</name>.<name>isNaN</name></name><argument_list>(<argument><expr><name>uvalue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{     
                    <expr_stmt><expr><name>maximum</name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>maximum</name></expr></argument>, <argument><expr><name>uvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></for>
        <if>if <condition>(<expr><name>minimum</name> == <name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr>)</condition><then> <block>{
            <return>return <expr><name>null</name></expr>;</return>
        }</block></then>
        <else>else <block>{
            <return>return <expr>new <call><name>Range</name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Finds the minimum domain (or X) value for the specified dataset.  This 
     * is easy if the dataset implements the {@link DomainInfo} interface (a 
     * good idea if there is an efficient way to determine the minimum value).
     * Otherwise, it involves iterating over the entire data-set.
     * &lt;p&gt;
     * Returns &lt;code&gt;null&lt;/code&gt; if all the data values in the dataset are 
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return The minimum value (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Number</name></type> <name>findMinimumDomainValue</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>Number</name></type> <name>result</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <comment type="line">// if the dataset implements DomainInfo, life is easy</comment>
        <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>DomainInfo</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>DomainInfo</name></type> <name>info</name> =<init> <expr>(<name>DomainInfo</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>Double</name><argument_list>(<argument><expr><call><name><name>info</name>.<name>getDomainLowerBound</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>minimum</name> =<init> <expr><name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getSeriesCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>itemCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getItemCount</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>itemCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{

                    <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>IntervalXYDataset</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>IntervalXYDataset</name></type> <name>intervalXYData</name> 
                            =<init> <expr>(<name>IntervalXYDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>value</name> = <call><name><name>intervalXYData</name>.<name>getStartXValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><name>value</name> = <call><name><name>dataset</name>.<name>getXValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <if>if <condition>(<expr>!<call><name><name>Double</name>.<name>isNaN</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>minimum</name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                }</block></for>
            }</block></for>
            <if>if <condition>(<expr><name>minimum</name> == <name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <name>null</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>result</name> = new <call><name>Double</name><argument_list>(<argument><expr><name>minimum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>

        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>
    
    <comment type="javadoc">/**
     * Returns the maximum domain value for the specified dataset.  This is 
     * easy if the dataset implements the {@link DomainInfo} interface (a good 
     * idea if there is an efficient way to determine the maximum value).  
     * Otherwise, it involves iterating over the entire data-set.  Returns 
     * &lt;code&gt;null&lt;/code&gt; if all the data values in the dataset are 
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return The maximum value (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Number</name></type> <name>findMaximumDomainValue</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>Number</name></type> <name>result</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <comment type="line">// if the dataset implements DomainInfo, life is easy</comment>
        <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>DomainInfo</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>DomainInfo</name></type> <name>info</name> =<init> <expr>(<name>DomainInfo</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>Double</name><argument_list>(<argument><expr><call><name><name>info</name>.<name>getDomainUpperBound</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>

        <comment type="line">// hasn't implemented DomainInfo, so iterate...</comment>
        <else>else <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>maximum</name> =<init> <expr><name><name>Double</name>.<name>NEGATIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getSeriesCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>itemCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getItemCount</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>itemCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{

                    <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>IntervalXYDataset</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>IntervalXYDataset</name></type> <name>intervalXYData</name> 
                            =<init> <expr>(<name>IntervalXYDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>value</name> = <call><name><name>intervalXYData</name>.<name>getEndXValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><name>value</name> = <call><name><name>dataset</name>.<name>getXValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <if>if <condition>(<expr>!<call><name><name>Double</name>.<name>isNaN</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>maximum</name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>maximum</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></for>
            <if>if <condition>(<expr><name>maximum</name> == <name><name>Double</name>.<name>NEGATIVE_INFINITY</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <name>null</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>result</name> = new <call><name>Double</name><argument_list>(<argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

        }</block></else></if>
        
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the minimum range value for the specified dataset.  This is 
     * easy if the dataset implements the {@link RangeInfo} interface (a good
     * idea if there is an efficient way to determine the minimum value).  
     * Otherwise, it involves iterating over the entire data-set.  Returns 
     * &lt;code&gt;null&lt;/code&gt; if all the data values in the dataset are 
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return The minimum value (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Number</name></type> <name>findMinimumRangeValue</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{

        <comment type="line">// check parameters...</comment>
        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <comment type="line">// work out the minimum value...</comment>
        <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>RangeInfo</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>RangeInfo</name></type> <name>info</name> =<init> <expr>(<name>RangeInfo</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>Double</name><argument_list>(<argument><expr><call><name><name>info</name>.<name>getRangeLowerBound</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>

        <comment type="line">// hasn't implemented RangeInfo, so we'll have to iterate...</comment>
        <else>else <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>minimum</name> =<init> <expr><name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>itemCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getColumnCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>itemCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>Number</name></type> <name>value</name></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>IntervalCategoryDataset</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>IntervalCategoryDataset</name></type> <name>icd</name> 
                            =<init> <expr>(<name>IntervalCategoryDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>value</name> = <call><name><name>icd</name>.<name>getStartValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><name>value</name> = <call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <if>if <condition>(<expr><name>value</name> != <name>null</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>minimum</name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><call><name><name>value</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></for>
            <if>if <condition>(<expr><name>minimum</name> == <name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr>)</condition><then> <block>{
                <return>return <expr><name>null</name></expr>;</return>
            }</block></then>
            <else>else <block>{
                <return>return <expr>new <call><name>Double</name><argument_list>(<argument><expr><name>minimum</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>

        }</block></else></if>

    }</block></function>

    <comment type="javadoc">/**
     * Returns the minimum range value for the specified dataset.  This is 
     * easy if the dataset implements the {@link RangeInfo} interface (a good
     * idea if there is an efficient way to determine the minimum value).  
     * Otherwise, it involves iterating over the entire data-set.  Returns 
     * &lt;code&gt;null&lt;/code&gt; if all the data values in the dataset are 
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return The minimum value (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Number</name></type> <name>findMinimumRangeValue</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{

        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <comment type="line">// work out the minimum value...</comment>
        <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>RangeInfo</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>RangeInfo</name></type> <name>info</name> =<init> <expr>(<name>RangeInfo</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>Double</name><argument_list>(<argument><expr><call><name><name>info</name>.<name>getRangeLowerBound</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>

        <comment type="line">// hasn't implemented RangeInfo, so we'll have to iterate...</comment>
        <else>else <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>minimum</name> =<init> <expr><name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getSeriesCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>itemCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getItemCount</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>itemCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{

                    <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>IntervalXYDataset</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>IntervalXYDataset</name></type> <name>intervalXYData</name> 
                            =<init> <expr>(<name>IntervalXYDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>value</name> = <call><name><name>intervalXYData</name>.<name>getStartYValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>OHLCDataset</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>OHLCDataset</name></type> <name>highLowData</name> =<init> <expr>(<name>OHLCDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>value</name> = <call><name><name>highLowData</name>.<name>getLowValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><name>value</name> = <call><name><name>dataset</name>.<name>getYValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if></else></if>
                    <if>if <condition>(<expr>!<call><name><name>Double</name>.<name>isNaN</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>minimum</name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                }</block></for>
            }</block></for>
            <if>if <condition>(<expr><name>minimum</name> == <name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr>)</condition><then> <block>{
                <return>return <expr><name>null</name></expr>;</return>
            }</block></then>
            <else>else <block>{
                <return>return <expr>new <call><name>Double</name><argument_list>(<argument><expr><name>minimum</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>

        }</block></else></if>

    }</block></function>

    <comment type="javadoc">/**
     * Returns the maximum range value for the specified dataset.  This is easy
     * if the dataset implements the {@link RangeInfo} interface (a good idea 
     * if there is an efficient way to determine the maximum value).  
     * Otherwise, it involves iterating over the entire data-set.  Returns 
     * &lt;code&gt;null&lt;/code&gt; if all the data values are &lt;code&gt;null&lt;/code&gt;.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return The maximum value (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Number</name></type> <name>findMaximumRangeValue</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{

        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <comment type="line">// work out the minimum value...</comment>
        <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>RangeInfo</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>RangeInfo</name></type> <name>info</name> =<init> <expr>(<name>RangeInfo</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>Double</name><argument_list>(<argument><expr><call><name><name>info</name>.<name>getRangeUpperBound</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>

        <comment type="line">// hasn't implemented RangeInfo, so we'll have to iterate...</comment>
        <else>else <block>{

            <decl_stmt><decl><type><name>double</name></type> <name>maximum</name> =<init> <expr><name><name>Double</name>.<name>NEGATIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>itemCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getColumnCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>itemCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>Number</name></type> <name>value</name></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>IntervalCategoryDataset</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>IntervalCategoryDataset</name></type> <name>icd</name> 
                            =<init> <expr>(<name>IntervalCategoryDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>value</name> = <call><name><name>icd</name>.<name>getEndValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><name>value</name> = <call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <if>if <condition>(<expr><name>value</name> != <name>null</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>maximum</name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>maximum</name></expr></argument>, <argument><expr><call><name><name>value</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></for>
            <if>if <condition>(<expr><name>maximum</name> == <name><name>Double</name>.<name>NEGATIVE_INFINITY</name></name></expr>)</condition><then> <block>{
                <return>return <expr><name>null</name></expr>;</return>
            }</block></then>
            <else>else <block>{
                <return>return <expr>new <call><name>Double</name><argument_list>(<argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>

        }</block></else></if>

    }</block></function>

    <comment type="javadoc">/**
     * Returns the maximum range value for the specified dataset.  This is 
     * easy if the dataset implements the {@link RangeInfo} interface (a good 
     * idea if there is an efficient way to determine the maximum value).  
     * Otherwise, it involves iterating over the entire data-set.  Returns 
     * &lt;code&gt;null&lt;/code&gt; if all the data values are &lt;code&gt;null&lt;/code&gt;.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return The maximum value (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Number</name></type> <name>findMaximumRangeValue</name><parameter_list>(<param><decl><type><name>XYDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{

        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <comment type="line">// work out the minimum value...</comment>
        <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>RangeInfo</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>RangeInfo</name></type> <name>info</name> =<init> <expr>(<name>RangeInfo</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>Double</name><argument_list>(<argument><expr><call><name><name>info</name>.<name>getRangeUpperBound</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>

        <comment type="line">// hasn't implemented RangeInfo, so we'll have to iterate...</comment>
        <else>else  <block>{

            <decl_stmt><decl><type><name>double</name></type> <name>maximum</name> =<init> <expr><name><name>Double</name>.<name>NEGATIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getSeriesCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>itemCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getItemCount</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>itemCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>IntervalXYDataset</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>IntervalXYDataset</name></type> <name>intervalXYData</name> 
                            =<init> <expr>(<name>IntervalXYDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>value</name> = <call><name><name>intervalXYData</name>.<name>getEndYValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name>dataset</name> <name>instanceof</name> <name>OHLCDataset</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>OHLCDataset</name></type> <name>highLowData</name> =<init> <expr>(<name>OHLCDataset</name>) <name>dataset</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>value</name> = <call><name><name>highLowData</name>.<name>getHighValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><name>value</name> = <call><name><name>dataset</name>.<name>getYValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if></else></if>
                    <if>if <condition>(<expr>!<call><name><name>Double</name>.<name>isNaN</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>maximum</name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>maximum</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></for>
            <if>if <condition>(<expr><name>maximum</name> == <name><name>Double</name>.<name>NEGATIVE_INFINITY</name></name></expr>)</condition><then> <block>{
                <return>return <expr><name>null</name></expr>;</return>
            }</block></then>
            <else>else <block>{
                <return>return <expr>new <call><name>Double</name><argument_list>(<argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>

        }</block></else></if>

    }</block></function>

    <comment type="javadoc">/**
     * Returns the minimum and maximum values for the dataset's range 
     * (y-values), assuming that the series in one category are stacked.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     *
     * @return The range (&lt;code&gt;null&lt;/code&gt; if the dataset contains no values).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findStackedRangeBounds</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>findStackedRangeBounds</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr>0.0</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the minimum and maximum values for the dataset's range 
     * (y-values), assuming that the series in one category are stacked.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param base  the base value for the bars.
     *
     * @return The range (&lt;code&gt;null&lt;/code&gt; if the dataset contains no values).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findStackedRangeBounds</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>, 
            <param><decl><type><name>double</name></type> <name>base</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>Range</name></type> <name>result</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>minimum</name> =<init> <expr><name><name>Double</name>.<name>POSITIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>maximum</name> =<init> <expr><name><name>Double</name>.<name>NEGATIVE_INFINITY</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>categoryCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getColumnCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>categoryCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>positive</name> =<init> <expr><name>base</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>negative</name> =<init> <expr><name>base</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>Number</name></type> <name>number</name> =<init> <expr><call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>number</name> != <name>null</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>double</name></type> <name>value</name> =<init> <expr><call><name><name>number</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>value</name> &gt; 0.0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>positive</name> = <name>positive</name> + <name>value</name></expr>;</expr_stmt>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>value</name> &lt; 0.0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>negative</name> = <name>negative</name> + <name>value</name></expr>;</expr_stmt>  
                        <comment type="line">// '+', remember value is negative</comment>
                    }</block></then></if>
                }</block></then></if>
            }</block></for>
            <expr_stmt><expr><name>minimum</name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>negative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>maximum</name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>maximum</name></expr></argument>, <argument><expr><name>positive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <if>if <condition>(<expr><name>minimum</name> &lt;= <name>maximum</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = new <call><name>Range</name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>result</name></expr>;</return>

    }</block></function>

    <comment type="javadoc">/**
     * Returns the minimum and maximum values for the dataset's range 
     * (y-values), assuming that the series in one category are stacked.
     *
     * @param dataset  the dataset.
     * @param map  a structure that maps series to groups.
     *
     * @return The value range (&lt;code&gt;null&lt;/code&gt; if the dataset contains no 
     *         values).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findStackedRangeBounds</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>,
                                               <param><decl><type><name>KeyToGroupMap</name></type> <name>map</name></decl></param>)</parameter_list> <block>{
    
        <decl_stmt><decl><type><name>Range</name></type> <name>result</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>dataset</name> != <name>null</name></expr>)</condition><then> <block>{
            
            <comment type="line">// create an array holding the group indices...</comment>
            <decl_stmt><decl><type><name>int</name><index>[]</index></type> <name>groupIndex</name> =<init> <expr>new <name><name>int</name><index>[<expr><call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name><name>groupIndex</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name><name>map</name>.<name>getGroupIndex</name></name><argument_list>(
                    <argument><expr><call><name><name>map</name>.<name>getGroup</name></name><argument_list>(<argument><expr><call><name><name>dataset</name>.<name>getRowKey</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
                )</argument_list></call></expr>;</expr_stmt>   
            }</block></for>
            
            <comment type="line">// minimum and maximum for each group...</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>groupCount</name> =<init> <expr><call><name><name>map</name>.<name>getGroupCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name><index>[]</index></type> <name>minimum</name> =<init> <expr>new <name><name>double</name><index>[<expr><name>groupCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name><index>[]</index></type> <name>maximum</name> =<init> <expr>new <name><name>double</name><index>[<expr><name>groupCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            
            <decl_stmt><decl><type><name>int</name></type> <name>categoryCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getColumnCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>categoryCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>double</name><index>[]</index></type> <name>positive</name> =<init> <expr>new <name><name>double</name><index>[<expr><name>groupCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>double</name><index>[]</index></type> <name>negative</name> =<init> <expr>new <name><name>double</name><index>[<expr><name>groupCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>Number</name></type> <name>number</name> =<init> <expr><call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>number</name> != <name>null</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>double</name></type> <name>value</name> =<init> <expr><call><name><name>number</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>value</name> &gt; 0.0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>positive</name><index>[<expr><name><name>groupIndex</name><index>[<expr><name>series</name></expr>]</index></name></expr>]</index></name> 
                                 = <name><name>positive</name><index>[<expr><name><name>groupIndex</name><index>[<expr><name>series</name></expr>]</index></name></expr>]</index></name> + <name>value</name></expr>;</expr_stmt>
                        }</block></then></if>
                        <if>if <condition>(<expr><name>value</name> &lt; 0.0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>negative</name><index>[<expr><name><name>groupIndex</name><index>[<expr><name>series</name></expr>]</index></name></expr>]</index></name> 
                                 = <name><name>negative</name><index>[<expr><name><name>groupIndex</name><index>[<expr><name>series</name></expr>]</index></name></expr>]</index></name> + <name>value</name></expr>;</expr_stmt>
                                 <comment type="line">// '+', remember value is negative</comment>
                        }</block></then></if>
                    }</block></then></if>
                }</block></for>
                <for>for (<init><decl><type><name>int</name></type> <name>g</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>g</name> &lt; <name>groupCount</name></expr>;</condition> <incr><expr><name>g</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name><name>minimum</name><index>[<expr><name>g</name></expr>]</index></name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name><name>minimum</name><index>[<expr><name>g</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>negative</name><index>[<expr><name>g</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>maximum</name><index>[<expr><name>g</name></expr>]</index></name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name><name>maximum</name><index>[<expr><name>g</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>positive</name><index>[<expr><name>g</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></for>
            <for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>groupCount</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name>result</name> = <call><name><name>Range</name>.<name>combine</name></name><argument_list>(
                    <argument><expr><name>result</name></expr></argument>, <argument><expr>new <call><name>Range</name><argument_list>(<argument><expr><name><name>minimum</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>maximum</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>
                )</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
        <return>return <expr><name>result</name></expr>;</return>

    }</block></function>

    <comment type="javadoc">/**
     * Returns the minimum value in the dataset range, assuming that values in
     * each category are "stacked".
     *
     * @param dataset  the dataset.
     *
     * @return The minimum value.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Number</name></type> <name>findMinimumStackedRangeValue</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{

        <decl_stmt><decl><type><name>Number</name></type> <name>result</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>dataset</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>minimum</name> =<init> <expr>0.0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>categoryCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>categoryCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>double</name></type> <name>total</name> =<init> <expr>0.0</expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getColumnCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>Number</name></type> <name>number</name> =<init> <expr><call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>number</name> != <name>null</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>double</name></type> <name>value</name> =<init> <expr><call><name><name>number</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>value</name> &lt; 0.0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>total</name> = <name>total</name> + <name>value</name></expr>;</expr_stmt>  
                            <comment type="line">// '+', remember value is negative</comment>
                        }</block></then></if>
                    }</block></then></if>
                }</block></for>
                <expr_stmt><expr><name>minimum</name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            }</block></for>
            <expr_stmt><expr><name>result</name> = new <call><name>Double</name><argument_list>(<argument><expr><name>minimum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>result</name></expr>;</return>

    }</block></function>

    <comment type="javadoc">/**
     * Returns the maximum value in the dataset range, assuming that values in
     * each category are "stacked".
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; permitted).
     *
     * @return The maximum value (possibly &lt;code&gt;null&lt;/code&gt;).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Number</name></type> <name>findMaximumStackedRangeValue</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{

        <decl_stmt><decl><type><name>Number</name></type> <name>result</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>dataset</name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>maximum</name> =<init> <expr>0.0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>categoryCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getColumnCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>item</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>item</name> &lt; <name>categoryCount</name></expr>;</condition> <incr><expr><name>item</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>double</name></type> <name>total</name> =<init> <expr>0.0</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>int</name></type> <name>series</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>series</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>series</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>Number</name></type> <name>number</name> =<init> <expr><call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>series</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>number</name> != <name>null</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>double</name></type> <name>value</name> =<init> <expr><call><name><name>number</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>value</name> &gt; 0.0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>total</name> = <name>total</name> + <name>value</name></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then></if>
                }</block></for>
                <expr_stmt><expr><name>maximum</name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>maximum</name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><name>result</name> = new <call><name>Double</name><argument_list>(<argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr><name>result</name></expr>;</return>

    }</block></function>

    <comment type="javadoc">/**
     * Returns the minimum and maximum values for the dataset's range,
     * assuming that the series are stacked.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * 
     * @return The range ([0.0, 0.0] if the dataset contains no values).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findStackedRangeBounds</name><parameter_list>(<param><decl><type><name>TableXYDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>findStackedRangeBounds</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr>0.0</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
    
    <comment type="javadoc">/**
     * Returns the minimum and maximum values for the dataset's range,
     * assuming that the series are stacked, using the specified base value.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * @param base  the base value.
     * 
     * @return The range (&lt;code&gt;null&lt;/code&gt; if the dataset contains no values).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findStackedRangeBounds</name><parameter_list>(<param><decl><type><name>TableXYDataset</name></type> <name>dataset</name></decl></param>, 
                                               <param><decl><type><name>double</name></type> <name>base</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>double</name></type> <name>minimum</name> =<init> <expr><name>base</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>maximum</name> =<init> <expr><name>base</name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>itemNo</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>itemNo</name> &lt; <call><name><name>dataset</name>.<name>getItemCount</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>itemNo</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>positive</name> =<init> <expr><name>base</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>negative</name> =<init> <expr><name>base</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getSeriesCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>seriesNo</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>seriesNo</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>seriesNo</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>double</name></type> <name>y</name> =<init> <expr><call><name><name>dataset</name>.<name>getYValue</name></name><argument_list>(<argument><expr><name>seriesNo</name></expr></argument>, <argument><expr><name>itemNo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<call><name><name>Double</name>.<name>isNaN</name></name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>y</name> &gt; 0.0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>positive</name> += <name>y</name></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><name>negative</name> += <name>y</name></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr><name>positive</name> &gt; <name>maximum</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>maximum</name> = <name>positive</name></expr>;</expr_stmt>
            }</block></then></if> 
            <if>if <condition>(<expr><name>negative</name> &lt; <name>minimum</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>minimum</name> = <name>negative</name></expr>;</expr_stmt>
            }</block></then></if> 
        }</block></for>
        <if>if <condition>(<expr><name>minimum</name> &lt;= <name>maximum</name></expr>)</condition><then> <block>{
            <return>return <expr>new <call><name>Range</name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else <block>{
            <return>return <expr><name>null</name></expr>;</return>   
        }</block></else></if>
    }</block></function>
    
    <comment type="javadoc">/**
     * Calculates the total for the y-values in all series for a given item
     * index.
     * 
     * @param dataset  the dataset.
     * @param item  the item index.
     * 
     * @return The total.
     * 
     * @since 1.0.5
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>double</name></type> <name>calculateStackTotal</name><parameter_list>(<param><decl><type><name>TableXYDataset</name></type> <name>dataset</name></decl></param>, <param><decl><type><name>int</name></type> <name>item</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>double</name></type> <name>total</name> =<init> <expr>0.0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>seriesCount</name> =<init> <expr><call><name><name>dataset</name>.<name>getSeriesCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>s</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>s</name> &lt; <name>seriesCount</name></expr>;</condition> <incr><expr><name>s</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>value</name> =<init> <expr><call><name><name>dataset</name>.<name>getYValue</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>Double</name>.<name>isNaN</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>total</name> = <name>total</name> + <name>value</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>total</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Calculates the range of values for a dataset where each item is the 
     * running total of the items for the current series.
     * 
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; not permitted).
     * 
     * @return The range.
     * 
     * @see #findRangeBounds(CategoryDataset)
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Range</name></type> <name>findCumulativeRangeBounds</name><parameter_list>(<param><decl><type><name>CategoryDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        
        <if>if <condition>(<expr><name>dataset</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Null 'dataset' argument."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        
        <decl_stmt><decl><type><name>boolean</name></type> <name>allItemsNull</name> =<init> <expr>true</expr></init></decl>;</decl_stmt> <comment type="line">// we'll set this to false if there is at </comment>
                                     <comment type="line">// least one non-null data item... </comment>
        <decl_stmt><decl><type><name>double</name></type> <name>minimum</name> =<init> <expr>0.0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>maximum</name> =<init> <expr>0.0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>row</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>row</name> &lt; <call><name><name>dataset</name>.<name>getRowCount</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>row</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>runningTotal</name> =<init> <expr>0.0</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>column</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>column</name> &lt; <call><name><name>dataset</name>.<name>getColumnCount</name></name><argument_list>()</argument_list></call> - 1</expr>;</condition> 
                 <incr><expr><name>column</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>Number</name></type> <name>n</name> =<init> <expr><call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>n</name> != <name>null</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>allItemsNull</name> = false</expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>double</name></type> <name>value</name> =<init> <expr><call><name><name>n</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>runningTotal</name> = <name>runningTotal</name> + <name>value</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>minimum</name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>runningTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>maximum</name> = <call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>maximum</name></expr></argument>, <argument><expr><name>runningTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>    
        }</block></for>
        <if>if <condition>(<expr>!<name>allItemsNull</name></expr>)</condition><then> <block>{
            <return>return <expr>new <call><name>Range</name><argument_list>(<argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else <block>{
            <return>return <expr><name>null</name></expr>;</return>
        }</block></else></if>
        
    }</block></function>

}</block></class>
</unit>
