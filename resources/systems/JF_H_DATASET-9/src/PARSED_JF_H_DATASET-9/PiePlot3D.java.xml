<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\daniel.rodriguez\IdeaProjects\biorimp\resources\systems\JF_H_DATASET-9\src\PiePlot3D.java"><comment type="block">/* ===========================================================
 * JFreeChart : a free chart library for the Java(tm) platform
 * ===========================================================
 *
 * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.
 *
 * Project Info:  http://www.jfree.org/jfreechart/index.html
 *
 * This library is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public License as published by 
 * the Free Software Foundation; either version 2.1 of the License, or 
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 
 * USA.  
 *
 * [Java is a trademark or registered trademark of Sun Microsystems, Inc. 
 * in the United States and other countries.]
 *
 * --------------
 * PiePlot3D.java
 * --------------
 * (C) Copyright 2000-2007, by Object Refinery and Contributors.
 *
 * Original Author:  Tomer Peretz;
 * Contributor(s):   Richard Atkinson;
 *                   David Gilbert (for Object Refinery Limited);
 *                   Xun Kang;
 *                   Christian W. Zuckschwerdt;
 *                   Arnaud Lelievre;
 *                   Dave Crane;
 *
 * Changes
 * -------
 * 21-Jun-2002 : Version 1;
 * 31-Jul-2002 : Modified to use startAngle and direction, drawing modified so 
 *               that charts render with foreground alpha &lt; 1.0 (DG);
 * 05-Aug-2002 : Small modification to draw method to support URLs for HTML 
 *               image maps (RA);
 * 26-Sep-2002 : Fixed errors reported by Checkstyle (DG);
 * 18-Oct-2002 : Added drawing bug fix sent in by Xun Kang, and made a couple 
 *               of other related fixes (DG);
 * 30-Oct-2002 : Changed the PieDataset interface. Fixed another drawing 
 *               bug (DG);
 * 12-Nov-2002 : Fixed null pointer exception for zero or negative values (DG);
 * 07-Mar-2003 : Modified to pass pieIndex on to PieSectionEntity (DG);
 * 21-Mar-2003 : Added workaround for bug id 620031 (DG);
 * 26-Mar-2003 : Implemented Serializable (DG);
 * 30-Jul-2003 : Modified entity constructor (CZ);
 * 29-Aug-2003 : Small changes for API updates in PiePlot class (DG);
 * 02-Sep-2003 : Fixed bug where the 'no data' message is not displayed (DG);
 * 08-Sep-2003 : Added internationalization via use of properties 
 *               resourceBundle (RFE 690236) (AL); 
 * 29-Oct-2003 : Added workaround for font alignment in PDF output (DG);
 * 20-Nov-2003 : Fixed bug 845289 (sides not showing) (DG);
 * 25-Nov-2003 : Added patch (845095) to fix outline paint issues (DG);
 * 10-Mar-2004 : Numerous changes to enhance labelling (DG);
 * 31-Mar-2004 : Adjusted plot area when label generator is null (DG);
 * 08-Apr-2004 : Added flag to PiePlot class to control the treatment of null 
 *               values (DG);
 *               Added pieIndex to PieSectionEntity (DG);
 * 15-Nov-2004 : Removed creation of default tool tip generator (DG);
 * 16-Jun-2005 : Added default constructor (DG);
 * ------------- JFREECHART 1.0.x ---------------------------------------------
 * 27-Sep-2006 : Updated draw() method for new lookup methods (DG);
 * 22-Mar-2007 : Added equals() override (DG);
 * 18-Jun-2007 : Added handling for simple label option (DG);
 * 04-Oct-2007 : Added option to darken sides of plot - thanks to Alex Moots 
 *               (see patch 1805262) (DG);
 * 21-Nov-2007 : Changed default depth factor, fixed labelling bugs and added
 *               debug code - see debug flags in PiePlot class (DG);
 *
 */</comment>

<package>package <name><name>org</name>.<name>jfree</name>.<name>chart</name>.<name>plot</name></name>;</package>

<import>import <name><name>java</name>.<name>awt</name>.<name>AlphaComposite</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>Color</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>Composite</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>Font</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>FontMetrics</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>Graphics2D</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>Paint</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>Polygon</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>Shape</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>Stroke</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>geom</name>.<name>Arc2D</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>geom</name>.<name>Area</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>geom</name>.<name>Ellipse2D</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>geom</name>.<name>Point2D</name></name>;</import>
<import>import <name><name>java</name>.<name>awt</name>.<name>geom</name>.<name>Rectangle2D</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>Serializable</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Iterator</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>

<import>import <name><name>org</name>.<name>jfree</name>.<name>chart</name>.<name>entity</name>.<name>EntityCollection</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>chart</name>.<name>entity</name>.<name>PieSectionEntity</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>chart</name>.<name>event</name>.<name>PlotChangeEvent</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>chart</name>.<name>labels</name>.<name>PieToolTipGenerator</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>general</name>.<name>DatasetUtilities</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>data</name>.<name>general</name>.<name>PieDataset</name></name>;</import>
<import>import <name><name>org</name>.<name>jfree</name>.<name>ui</name>.<name>RectangleInsets</name></name>;</import>

<comment type="javadoc">/**
 * A plot that displays data in the form of a 3D pie chart, using data from
 * any class that implements the {@link PieDataset} interface.
 * &lt;P&gt;
 * Although this class extends {@link PiePlot}, it does not currently support
 * exploded sections.
 */</comment>
<class><specifier>public</specifier> class <name>PiePlot3D</name> <super><extends>extends <name>PiePlot</name></extends> <implements>implements <name>Serializable</name></implements></super> <block>{

    <comment type="javadoc">/** For serialization. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> =<init> <expr>3408984188945161432L</expr></init></decl>;</decl_stmt>
    
    <comment type="javadoc">/** The factor of the depth of the pie from the plot height */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>double</name></type> <name>depthFactor</name> =<init> <expr>0.12</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** 
     * A flag that controls whether or not the sides of the pie chart
     * are rendered using a darker colour.
     * 
     *  @since 1.0.7.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>darkerSides</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>  <comment type="line">// default preserves previous </comment>
                                          <comment type="line">// behaviour</comment>
    
    <comment type="javadoc">/**
     * Creates a new instance with no dataset.
     */</comment>
    <constructor><specifier>public</specifier> <name>PiePlot3D</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
    }</block></constructor>
    
    <comment type="javadoc">/**
     * Creates a pie chart with a three dimensional effect using the specified 
     * dataset.
     *
     * @param dataset  the dataset (&lt;code&gt;null&lt;/code&gt; permitted).
     */</comment>
    <constructor><specifier>public</specifier> <name>PiePlot3D</name><parameter_list>(<param><decl><type><name>PieDataset</name></type> <name>dataset</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setCircular</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Returns the depth factor for the chart.
     *
     * @return The depth factor.
     * 
     * @see #setDepthFactor(double)
     */</comment>
    <function><type><specifier>public</specifier> <name>double</name></type> <name>getDepthFactor</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>depthFactor</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets the pie depth as a percentage of the height of the plot area, and
     * sends a {@link PlotChangeEvent} to all registered listeners.
     *
     * @param factor  the depth factor (for example, 0.20 is twenty percent).
     * 
     * @see #getDepthFactor()
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDepthFactor</name><parameter_list>(<param><decl><type><name>double</name></type> <name>factor</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>depthFactor</name></name> = <name>factor</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyListeners</name><argument_list>(<argument><expr>new <call><name>PlotChangeEvent</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Returns a flag that controls whether or not the sides of the pie chart
     * are rendered using a darker colour.  This is only applied if the
     * section colour is an instance of {@link java.awt.Color}.
     *
     * @return A boolean.
     * 
     * @see #setDarkerSides(boolean)
     * 
     * @since 1.0.7
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getDarkerSides</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>darkerSides</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Sets a flag that controls whether or not the sides of the pie chart
     * are rendered using a darker colour, and sends a {@link PlotChangeEvent} 
     * to all registered listeners.  This is only applied if the
     * section colour is an instance of {@link java.awt.Color}.
     *
     * @param darker true to darken the sides, false to use the default 
     *         behaviour.
     * 
     * @see #getDarkerSides()
     * 
     * @since 1.0.7.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setDarkerSides</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>darker</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>darkerSides</name></name> = <name>darker</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyListeners</name><argument_list>(<argument><expr>new <call><name>PlotChangeEvent</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Draws the plot on a Java 2D graphics device (such as the screen or a 
     * printer).  This method is called by the 
     * {@link org.jfree.chart.JFreeChart} class, you don't normally need 
     * to call it yourself.
     *
     * @param g2  the graphics device.
     * @param plotArea  the area within which the plot should be drawn.
     * @param anchor  the anchor point.
     * @param parentState  the state from the parent plot, if there is one.
     * @param info  collects info about the drawing 
     *              (&lt;code&gt;null&lt;/code&gt; permitted).
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>draw</name><parameter_list>(<param><decl><type><name>Graphics2D</name></type> <name>g2</name></decl></param>, <param><decl><type><name>Rectangle2D</name></type> <name>plotArea</name></decl></param>, <param><decl><type><name>Point2D</name></type> <name>anchor</name></decl></param>,
                     <param><decl><type><name>PlotState</name></type> <name>parentState</name></decl></param>,
                     <param><decl><type><name>PlotRenderingInfo</name></type> <name>info</name></decl></param>)</parameter_list> <block>{

        <comment type="line">// adjust for insets...</comment>
        <decl_stmt><decl><type><name>RectangleInsets</name></type> <name>insets</name> =<init> <expr><call><name>getInsets</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>insets</name>.<name>trim</name></name><argument_list>(<argument><expr><name>plotArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Rectangle2D</name></type> <name>originalPlotArea</name> =<init> <expr>(<name>Rectangle2D</name>) <call><name><name>plotArea</name>.<name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>info</name> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>info</name>.<name>setPlotArea</name></name><argument_list>(<argument><expr><name>plotArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>info</name>.<name>setDataArea</name></name><argument_list>(<argument><expr><name>plotArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>drawBackground</name><argument_list>(<argument><expr><name>g2</name></expr></argument>, <argument><expr><name>plotArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Shape</name></type> <name>savedClip</name> =<init> <expr><call><name><name>g2</name>.<name>getClip</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>g2</name>.<name>clip</name></name><argument_list>(<argument><expr><name>plotArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// adjust the plot area by the interior spacing value</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>gapPercent</name> =<init> <expr><call><name>getInteriorGap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>labelPercent</name> =<init> <expr>0.0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>getLabelGenerator</name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>labelPercent</name> = <call><name>getLabelGap</name><argument_list>()</argument_list></call> + <call><name>getMaximumLabelWidth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>   
        }</block></then></if>
        <decl_stmt><decl><type><name>double</name></type> <name>gapHorizontal</name> =<init> <expr><call><name><name>plotArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call> * (<name>gapPercent</name> 
                + <name>labelPercent</name>) * 2.0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>gapVertical</name> =<init> <expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> * <name>gapPercent</name> * 2.0</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>DEBUG_DRAW_INTERIOR</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>hGap</name> =<init> <expr><call><name><name>plotArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call> * <call><name>getInteriorGap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>vGap</name> =<init> <expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> * <call><name>getInteriorGap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>igx1</name> =<init> <expr><call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call> + <name>hGap</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>igx2</name> =<init> <expr><call><name><name>plotArea</name>.<name>getMaxX</name></name><argument_list>()</argument_list></call> - <name>hGap</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>igy1</name> =<init> <expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call> + <name>vGap</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>igy2</name> =<init> <expr><call><name><name>plotArea</name>.<name>getMaxY</name></name><argument_list>()</argument_list></call> - <name>vGap</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name><name>Color</name>.<name>lightGray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(<argument><expr><name>igx1</name></expr></argument>, <argument><expr><name>igy1</name></expr></argument>, <argument><expr><name>igx2</name> - <name>igx1</name></expr></argument>, 
                    <argument><expr><name>igy2</name> - <name>igy1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>double</name></type> <name>linkX</name> =<init> <expr><call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call> + <name>gapHorizontal</name> / 2</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>linkY</name> =<init> <expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call> + <name>gapVertical</name> / 2</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>linkW</name> =<init> <expr><call><name><name>plotArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call> - <name>gapHorizontal</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>linkH</name> =<init> <expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> - <name>gapVertical</name></expr></init></decl>;</decl_stmt>
        
        <comment type="line">// make the link area a square if the pie chart is to be circular...</comment>
        <if>if <condition>(<expr><call><name>isCircular</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// is circular?</comment>
            <decl_stmt><decl><type><name>double</name></type> <name>min</name> =<init> <expr><call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>linkW</name></expr></argument>, <argument><expr><name>linkH</name></expr></argument>)</argument_list></call> / 2</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>linkX</name> = (<name>linkX</name> + <name>linkX</name> + <name>linkW</name>) / 2 - <name>min</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>linkY</name> = (<name>linkY</name> + <name>linkY</name> + <name>linkH</name>) / 2 - <name>min</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>linkW</name> = 2 * <name>min</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>linkH</name> = 2 * <name>min</name></expr>;</expr_stmt>
        }</block></then></if>
        
        <decl_stmt><decl><type><name>PiePlotState</name></type> <name>state</name> =<init> <expr><call><name>initialise</name><argument_list>(<argument><expr><name>g2</name></expr></argument>, <argument><expr><name>plotArea</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>null</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// the link area defines the dog leg points for the linking lines to </comment>
        <comment type="line">// the labels</comment>
        <decl_stmt><decl><type><name>Rectangle2D</name></type> <name>linkAreaXX</name> =<init> <expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(<argument><expr><name>linkX</name></expr></argument>, <argument><expr><name>linkY</name></expr></argument>, <argument><expr><name>linkW</name></expr></argument>, 
                <argument><expr><name>linkH</name> * (1 - <name><name>this</name>.<name>depthFactor</name></name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>state</name>.<name>setLinkArea</name></name><argument_list>(<argument><expr><name>linkAreaXX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>DEBUG_DRAW_LINK_AREA</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name><name>Color</name>.<name>blue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>linkAreaXX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name><name>Color</name>.<name>yellow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr>new <call><name><name>Ellipse2D</name>.<name>Double</name></name><argument_list>(<argument><expr><call><name><name>linkAreaXX</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>linkAreaXX</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>, 
                    <argument><expr><call><name><name>linkAreaXX</name>.<name>getWidth</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>linkAreaXX</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        
        <comment type="line">// the explode area defines the max circle/ellipse for the exploded pie </comment>
        <comment type="line">// sections.</comment>
        <comment type="line">// it is defined by shrinking the linkArea by the linkMargin factor.</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>hh</name> =<init> <expr><name>linkW</name> * <call><name>getLabelLinkMargin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>vv</name> =<init> <expr><name>linkH</name> * <call><name>getLabelLinkMargin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Rectangle2D</name></type> <name>explodeArea</name> =<init> <expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(<argument><expr><name>linkX</name> + <name>hh</name> / 2.0</expr></argument>, 
                <argument><expr><name>linkY</name> + <name>vv</name> / 2.0</expr></argument>, <argument><expr><name>linkW</name> - <name>hh</name></expr></argument>, <argument><expr><name>linkH</name> - <name>vv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       
        <expr_stmt><expr><call><name><name>state</name>.<name>setExplodedPieArea</name></name><argument_list>(<argument><expr><name>explodeArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="line">// the pie area defines the circle/ellipse for regular pie sections.</comment>
        <comment type="line">// it is defined by shrinking the explodeArea by the explodeMargin </comment>
        <comment type="line">// factor. </comment>
        <decl_stmt><decl><type><name>double</name></type> <name>maximumExplodePercent</name> =<init> <expr><call><name>getMaximumExplodePercent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>percent</name> =<init> <expr><name>maximumExplodePercent</name> / (1.0 + <name>maximumExplodePercent</name>)</expr></init></decl>;</decl_stmt>
        
        <decl_stmt><decl><type><name>double</name></type> <name>h1</name> =<init> <expr><call><name><name>explodeArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call> * <name>percent</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>v1</name> =<init> <expr><call><name><name>explodeArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> * <name>percent</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Rectangle2D</name></type> <name>pieArea</name> =<init> <expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(<argument><expr><call><name><name>explodeArea</name>.<name>getX</name></name><argument_list>()</argument_list></call> 
                + <name>h1</name> / 2.0</expr></argument>, <argument><expr><call><name><name>explodeArea</name>.<name>getY</name></name><argument_list>()</argument_list></call> + <name>v1</name> / 2.0</expr></argument>,
                <argument><expr><call><name><name>explodeArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call> - <name>h1</name></expr></argument>, <argument><expr><call><name><name>explodeArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> - <name>v1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// the link area defines the dog-leg point for the linking lines to </comment>
        <comment type="line">// the labels</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>depth</name> =<init> <expr><call>(<name>int</name>) <argument_list>(<argument><expr><call><name><name>pieArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> * <name><name>this</name>.<name>depthFactor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Rectangle2D</name></type> <name>linkArea</name> =<init> <expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(<argument><expr><name>linkX</name></expr></argument>, <argument><expr><name>linkY</name></expr></argument>, <argument><expr><name>linkW</name></expr></argument>, 
                <argument><expr><name>linkH</name> - <name>depth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>state</name>.<name>setLinkArea</name></name><argument_list>(<argument><expr><name>linkArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   

        <expr_stmt><expr><call><name><name>state</name>.<name>setPieArea</name></name><argument_list>(<argument><expr><name>pieArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>state</name>.<name>setPieCenterX</name></name><argument_list>(<argument><expr><call><name><name>pieArea</name>.<name>getCenterX</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>state</name>.<name>setPieCenterY</name></name><argument_list>(<argument><expr><call><name><name>pieArea</name>.<name>getCenterY</name></name><argument_list>()</argument_list></call> - <name>depth</name> / 2.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>state</name>.<name>setPieWRadius</name></name><argument_list>(<argument><expr><call><name><name>pieArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call> / 2.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>state</name>.<name>setPieHRadius</name></name><argument_list>(<argument><expr>(<call><name><name>pieArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> - <name>depth</name>) / 2.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// get the data source - return if null;</comment>
        <decl_stmt><decl><type><name>PieDataset</name></type> <name>dataset</name> =<init> <expr><call><name>getDataset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>DatasetUtilities</name>.<name>isEmptyOrNull</name></name><argument_list>(<argument><expr><call><name>getDataset</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>drawNoDataMessage</name><argument_list>(<argument><expr><name>g2</name></expr></argument>, <argument><expr><name>plotArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setClip</name></name><argument_list>(<argument><expr><name>savedClip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>drawOutline</name><argument_list>(<argument><expr><name>g2</name></expr></argument>, <argument><expr><name>plotArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <comment type="line">// if too any elements</comment>
        <if>if <condition>(<expr><call><name><name>dataset</name>.<name>getKeys</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; <call><name><name>plotArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>text</name> =<init> <expr>"Too many elements"</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Font</name></type> <name>sfont</name> =<init> <expr>new <call><name>Font</name><argument_list>(<argument><expr>"dialog"</expr></argument>, <argument><expr><name><name>Font</name>.<name>BOLD</name></name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setFont</name></name><argument_list>(<argument><expr><name>sfont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>FontMetrics</name></type> <name>fm</name> =<init> <expr><call><name><name>g2</name>.<name>getFontMetrics</name></name><argument_list>(<argument><expr><name>sfont</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>stringWidth</name> =<init> <expr><call><name><name>fm</name>.<name>stringWidth</name></name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>g2</name>.<name>drawString</name></name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call> + (<call><name><name>plotArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call> 
                    - <name>stringWidth</name>) / 2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call> 
                    + (<call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> / 2)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <comment type="line">// if we are drawing a perfect circle, we need to readjust the top left</comment>
        <comment type="line">// coordinates of the drawing area for the arcs to arrive at this</comment>
        <comment type="line">// effect.</comment>
        <if>if <condition>(<expr><call><name>isCircular</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>min</name> =<init> <expr><call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><call><name><name>plotArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call></expr></argument>, 
                    <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> / 2</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>plotArea</name> = new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(<argument><expr><call><name><name>plotArea</name>.<name>getCenterX</name></name><argument_list>()</argument_list></call> - <name>min</name></expr></argument>, 
                    <argument><expr><call><name><name>plotArea</name>.<name>getCenterY</name></name><argument_list>()</argument_list></call> - <name>min</name></expr></argument>, <argument><expr>2 * <name>min</name></expr></argument>, <argument><expr>2 * <name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="line">// get a list of keys...</comment>
        <decl_stmt><decl><type><name>List</name></type> <name>sectionKeys</name> =<init> <expr><call><name><name>dataset</name>.<name>getKeys</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>sectionKeys</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>

        <comment type="line">// establish the coordinates of the top left corner of the drawing area</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>arcX</name> =<init> <expr><call><name><name>pieArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>arcY</name> =<init> <expr><call><name><name>pieArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">//g2.clip(clipArea);</comment>
        <decl_stmt><decl><type><name>Composite</name></type> <name>originalComposite</name> =<init> <expr><call><name><name>g2</name>.<name>getComposite</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>g2</name>.<name>setComposite</name></name><argument_list>(<argument><expr><call><name><name>AlphaComposite</name>.<name>getInstance</name></name><argument_list>(<argument><expr><name><name>AlphaComposite</name>.<name>SRC_OVER</name></name></expr></argument>, 
                <argument><expr><call><name>getForegroundAlpha</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>double</name></type> <name>totalValue</name> =<init> <expr><call><name><name>DatasetUtilities</name>.<name>calculatePieDatasetTotal</name></name><argument_list>(<argument><expr><name>dataset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>runningTotal</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>depth</name> &lt; 0</expr>)</condition><then> <block>{
            <return>return;</return>  <comment type="line">// if depth is negative don't draw anything</comment>
        }</block></then></if>

        <decl_stmt><decl><type><name>ArrayList</name></type> <name>arcList</name> =<init> <expr>new <call><name>ArrayList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Arc2D</name>.<name>Double</name></name></type> <name>arc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Paint</name></type> <name>paint</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Paint</name></type> <name>outlinePaint</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Stroke</name></type> <name>outlineStroke</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Iterator</name></type> <name>iterator</name> =<init> <expr><call><name><name>sectionKeys</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iterator</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{

            <decl_stmt><decl><type><name>Comparable</name></type> <name>currentKey</name> =<init> <expr>(<name>Comparable</name>) <call><name><name>iterator</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Number</name></type> <name>dataValue</name> =<init> <expr><call><name><name>dataset</name>.<name>getValue</name></name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>dataValue</name> == <name>null</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>arcList</name>.<name>add</name></name><argument_list>(<argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <decl_stmt><decl><type><name>double</name></type> <name>value</name> =<init> <expr><call><name><name>dataValue</name>.<name>doubleValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>value</name> &lt;= 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>arcList</name>.<name>add</name></name><argument_list>(<argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <decl_stmt><decl><type><name>double</name></type> <name>startAngle</name> =<init> <expr><call><name>getStartAngle</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>direction</name> =<init> <expr><call><name>getDirection</name><argument_list>()</argument_list></call>.<call><name>getFactor</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>angle1</name> =<init> <expr><name>startAngle</name> + (<name>direction</name> * (<name>runningTotal</name> * 360)) 
                    / <name>totalValue</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>angle2</name> =<init> <expr><name>startAngle</name> + (<name>direction</name> * (<name>runningTotal</name> + <name>value</name>) 
                    * 360) / <name>totalValue</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>Math</name>.<name>abs</name></name><argument_list>(<argument><expr><name>angle2</name> - <name>angle1</name></expr></argument>)</argument_list></call> &gt; <call><name>getMinimumArcAngleToDraw</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>arcList</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name><name>Arc2D</name>.<name>Double</name></name><argument_list>(<argument><expr><name>arcX</name></expr></argument>, <argument><expr><name>arcY</name> + <name>depth</name></expr></argument>, 
                        <argument><expr><call><name><name>pieArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pieArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> - <name>depth</name></expr></argument>,
                        <argument><expr><name>angle1</name></expr></argument>, <argument><expr><name>angle2</name> - <name>angle1</name></expr></argument>, <argument><expr><name><name>Arc2D</name>.<name>PIE</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name><name>arcList</name>.<name>add</name></name><argument_list>(<argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>runningTotal</name> += <name>value</name></expr>;</expr_stmt>
        }</block></while>

        <decl_stmt><decl><type><name>Shape</name></type> <name>oldClip</name> =<init> <expr><call><name><name>g2</name>.<name>getClip</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Ellipse2D</name></type> <name>top</name> =<init> <expr>new <call><name><name>Ellipse2D</name>.<name>Double</name></name><argument_list>(<argument><expr><call><name><name>pieArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pieArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>, 
                <argument><expr><call><name><name>pieArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pieArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> - <name>depth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Ellipse2D</name></type> <name>bottom</name> =<init> <expr>new <call><name><name>Ellipse2D</name>.<name>Double</name></name><argument_list>(<argument><expr><call><name><name>pieArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pieArea</name>.<name>getY</name></name><argument_list>()</argument_list></call> 
                + <name>depth</name></expr></argument>, <argument><expr><call><name><name>pieArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pieArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> - <name>depth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Rectangle2D</name></type> <name>lower</name> =<init> <expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(<argument><expr><call><name><name>top</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, 
                <argument><expr><call><name><name>top</name>.<name>getCenterY</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>pieArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>bottom</name>.<name>getMaxY</name></name><argument_list>()</argument_list></call> 
                - <call><name><name>top</name>.<name>getCenterY</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Rectangle2D</name></type> <name>upper</name> =<init> <expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(<argument><expr><call><name><name>pieArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>top</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>, 
                <argument><expr><call><name><name>pieArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>bottom</name>.<name>getCenterY</name></name><argument_list>()</argument_list></call> - <call><name><name>top</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Area</name></type> <name>a</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>a</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>Area</name><argument_list>(<argument><expr><name>lower</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Area</name></type> <name>b</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr><name>bottom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>b</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>Area</name><argument_list>(<argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Area</name></type> <name>pie</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>pie</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Area</name></type> <name>front</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr><name>pie</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>front</name>.<name>subtract</name></name><argument_list>(<argument><expr>new <call><name>Area</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Area</name></type> <name>back</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr><name>pie</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>back</name>.<name>subtract</name></name><argument_list>(<argument><expr>new <call><name>Area</name><argument_list>(<argument><expr><name>bottom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// draw the bottom circle</comment>
        <decl_stmt><decl><type><name>int</name><index>[]</index></type> <name>xs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name><index>[]</index></type> <name>ys</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>arc</name> = new <call><name><name>Arc2D</name>.<name>Double</name></name><argument_list>(<argument><expr><name>arcX</name></expr></argument>, <argument><expr><name>arcY</name> + <name>depth</name></expr></argument>, <argument><expr><call><name><name>pieArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call></expr></argument>, 
                <argument><expr><call><name><name>pieArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> - <name>depth</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>360</expr></argument>, <argument><expr><name><name>Arc2D</name>.<name>PIE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>categoryCount</name> =<init> <expr><call><name><name>arcList</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>categoryIndex</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>categoryIndex</name> &lt; <name>categoryCount</name></expr>;</condition> 
                 <incr><expr><name>categoryIndex</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>arc</name> = (<name><name>Arc2D</name>.<name>Double</name></name>) <call><name><name>arcList</name>.<name>get</name></name><argument_list>(<argument><expr><name>categoryIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>arc</name> == <name>null</name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <decl_stmt><decl><type><name>Comparable</name></type> <name>key</name> =<init> <expr><call><name>getSectionKey</name><argument_list>(<argument><expr><name>categoryIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>paint</name> = <call><name>lookupSectionPaint</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>outlinePaint</name> = <call><name>lookupSectionOutlinePaint</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>outlineStroke</name> = <call><name>lookupSectionOutlineStroke</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>arc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setStroke</name></name><argument_list>(<argument><expr><name>outlineStroke</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>arc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Point2D</name></type> <name>p1</name> =<init> <expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// draw the height</comment>
            <expr_stmt><expr><name>xs</name> = new <name><name>int</name><index>[]</index></name> <block>{<expr>(<name>int</name>) <call><name><name>arc</name>.<name>getCenterX</name></name><argument_list>()</argument_list></call></expr>, <expr>(<name>int</name>) <call><name><name>arc</name>.<name>getCenterX</name></name><argument_list>()</argument_list></call></expr>,
                    <expr>(<name>int</name>) <call><name><name>p1</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr>, <expr>(<name>int</name>) <call><name><name>p1</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr>}</block></expr>;</expr_stmt>
            <expr_stmt><expr><name>ys</name> = new <name><name>int</name><index>[]</index></name> <block>{<expr>(<name>int</name>) <call><name><name>arc</name>.<name>getCenterY</name></name><argument_list>()</argument_list></call></expr>, <expr>(<name>int</name>) <call><name><name>arc</name>.<name>getCenterY</name></name><argument_list>()</argument_list></call> 
                    - <name>depth</name></expr>, <expr>(<name>int</name>) <call><name><name>p1</name>.<name>getY</name></name><argument_list>()</argument_list></call> - <name>depth</name></expr>, <expr>(<name>int</name>) <call><name><name>p1</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr>}</block></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Polygon</name></type> <name>polygon</name> =<init> <expr>new <call><name>Polygon</name><argument_list>(<argument><expr><name>xs</name></expr></argument>, <argument><expr><name>ys</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name><name>java</name>.<name>awt</name>.<name>Color</name>.<name>lightGray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>polygon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setStroke</name></name><argument_list>(<argument><expr><name>outlineStroke</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>polygon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></for>

        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name><name>Color</name>.<name>gray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// cycle through once drawing only the sides at the back...</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>cat</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>iterator</name> = <call><name><name>arcList</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name><name>iterator</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>Arc2D</name></type> <name>segment</name> =<init> <expr>(<name>Arc2D</name>) <call><name><name>iterator</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>segment</name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Comparable</name></type> <name>key</name> =<init> <expr><call><name>getSectionKey</name><argument_list>(<argument><expr><name>cat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>paint</name> = <call><name>lookupSectionPaint</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>outlinePaint</name> = <call><name>lookupSectionOutlinePaint</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>outlineStroke</name> = <call><name>lookupSectionOutlineStroke</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>drawSide</name><argument_list>(<argument><expr><name>g2</name></expr></argument>, <argument><expr><name>pieArea</name></expr></argument>, <argument><expr><name>segment</name></expr></argument>, <argument><expr><name>front</name></expr></argument>, <argument><expr><name>back</name></expr></argument>, <argument><expr><name>paint</name></expr></argument>, 
                        <argument><expr><name>outlinePaint</name></expr></argument>, <argument><expr><name>outlineStroke</name></expr></argument>, <argument><expr>false</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>cat</name>++</expr>;</expr_stmt>
        }</block></while>

        <comment type="line">// cycle through again drawing only the sides at the front...</comment>
        <expr_stmt><expr><name>cat</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>iterator</name> = <call><name><name>arcList</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name><name>iterator</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>Arc2D</name></type> <name>segment</name> =<init> <expr>(<name>Arc2D</name>) <call><name><name>iterator</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>segment</name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Comparable</name></type> <name>key</name> =<init> <expr><call><name>getSectionKey</name><argument_list>(<argument><expr><name>cat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>paint</name> = <call><name>lookupSectionPaint</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>outlinePaint</name> = <call><name>lookupSectionOutlinePaint</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>outlineStroke</name> = <call><name>lookupSectionOutlineStroke</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>drawSide</name><argument_list>(<argument><expr><name>g2</name></expr></argument>, <argument><expr><name>pieArea</name></expr></argument>, <argument><expr><name>segment</name></expr></argument>, <argument><expr><name>front</name></expr></argument>, <argument><expr><name>back</name></expr></argument>, <argument><expr><name>paint</name></expr></argument>, 
                        <argument><expr><name>outlinePaint</name></expr></argument>, <argument><expr><name>outlineStroke</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>cat</name>++</expr>;</expr_stmt>
        }</block></while>

        <expr_stmt><expr><call><name><name>g2</name>.<name>setClip</name></name><argument_list>(<argument><expr><name>oldClip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// draw the sections at the top of the pie (and set up tooltips)...</comment>
        <decl_stmt><decl><type><name>Arc2D</name></type> <name>upperArc</name></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>sectionIndex</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>sectionIndex</name> &lt; <name>categoryCount</name></expr>;</condition> 
                 <incr><expr><name>sectionIndex</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>arc</name> = (<name><name>Arc2D</name>.<name>Double</name></name>) <call><name><name>arcList</name>.<name>get</name></name><argument_list>(<argument><expr><name>sectionIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>arc</name> == <name>null</name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>upperArc</name> = new <call><name><name>Arc2D</name>.<name>Double</name></name><argument_list>(<argument><expr><name>arcX</name></expr></argument>, <argument><expr><name>arcY</name></expr></argument>, <argument><expr><call><name><name>pieArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>pieArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> - <name>depth</name></expr></argument>, <argument><expr><call><name><name>arc</name>.<name>getAngleStart</name></name><argument_list>()</argument_list></call></expr></argument>, 
                    <argument><expr><call><name><name>arc</name>.<name>getAngleExtent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Arc2D</name>.<name>PIE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <decl_stmt><decl><type><name>Comparable</name></type> <name>currentKey</name> =<init> <expr>(<name>Comparable</name>) <call><name><name>sectionKeys</name>.<name>get</name></name><argument_list>(<argument><expr><name>sectionIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>paint</name> = <call><name>lookupSectionPaint</name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>outlinePaint</name> = <call><name>lookupSectionOutlinePaint</name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>outlineStroke</name> = <call><name>lookupSectionOutlineStroke</name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>upperArc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setStroke</name></name><argument_list>(<argument><expr><name>outlineStroke</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>upperArc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

           <comment type="line">// add a tooltip for the section...</comment>
            <if>if <condition>(<expr><name>info</name> != <name>null</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>EntityCollection</name></type> <name>entities</name> 
                        =<init> <expr><call><name><name>info</name>.<name>getOwner</name></name><argument_list>()</argument_list></call>.<call><name>getEntityCollection</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>entities</name> != <name>null</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>String</name></type> <name>tip</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>PieToolTipGenerator</name></type> <name>tipster</name> =<init> <expr><call><name>getToolTipGenerator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>tipster</name> != <name>null</name></expr>)</condition><then> <block>{
                        <comment type="line">// @mgs: using the method's return value was missing </comment>
                        <expr_stmt><expr><name>tip</name> = <call><name><name>tipster</name>.<name>generateToolTip</name></name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr><name>currentKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <decl_stmt><decl><type><name>String</name></type> <name>url</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><call><name>getURLGenerator</name><argument_list>()</argument_list></call> != <name>null</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>url</name> = <call><name>getURLGenerator</name><argument_list>()</argument_list></call>.<call><name>generateURL</name><argument_list>(<argument><expr><name>dataset</name></expr></argument>, <argument><expr><name>currentKey</name></expr></argument>,
                                <argument><expr><call><name>getPieIndex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <decl_stmt><decl><type><name>PieSectionEntity</name></type> <name>entity</name> =<init> <expr>new <call><name>PieSectionEntity</name><argument_list>(
                            <argument><expr><name>upperArc</name></expr></argument>, <argument><expr><name>dataset</name></expr></argument>, <argument><expr><call><name>getPieIndex</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>sectionIndex</name></expr></argument>, 
                            <argument><expr><name>currentKey</name></expr></argument>, <argument><expr><name>tip</name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>entities</name>.<name>add</name></name><argument_list>(<argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
            <decl_stmt><decl><type><name>List</name></type> <name>keys</name> =<init> <expr><call><name><name>dataset</name>.<name>getKeys</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Rectangle2D</name></type> <name>adjustedPlotArea</name> =<init> <expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                    <argument><expr><call><name><name>originalPlotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>originalPlotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>, 
                    <argument><expr><call><name><name>originalPlotArea</name>.<name>getWidth</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>originalPlotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call> 
                    - <name>depth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name>getSimpleLabels</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>drawSimpleLabels</name><argument_list>(<argument><expr><name>g2</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>totalValue</name></expr></argument>, <argument><expr><name>adjustedPlotArea</name></expr></argument>, 
                        <argument><expr><name>linkArea</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>drawLabels</name><argument_list>(<argument><expr><name>g2</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>totalValue</name></expr></argument>, <argument><expr><name>adjustedPlotArea</name></expr></argument>, <argument><expr><name>linkArea</name></expr></argument>, 
                        <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>

        <expr_stmt><expr><call><name><name>g2</name>.<name>setClip</name></name><argument_list>(<argument><expr><name>savedClip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>g2</name>.<name>setComposite</name></name><argument_list>(<argument><expr><name>originalComposite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>drawOutline</name><argument_list>(<argument><expr><name>g2</name></expr></argument>, <argument><expr><name>originalPlotArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block></function>

    <comment type="javadoc">/**
     * Draws the side of a pie section.
     *
     * @param g2  the graphics device.
     * @param plotArea  the plot area.
     * @param arc  the arc.
     * @param front  the front of the pie.
     * @param back  the back of the pie.
     * @param paint  the color.
     * @param outlinePaint  the outline paint.
     * @param outlineStroke  the outline stroke.
     * @param drawFront  draw the front?
     * @param drawBack  draw the back?
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>drawSide</name><parameter_list>(<param><decl><type><name>Graphics2D</name></type> <name>g2</name></decl></param>,
                            <param><decl><type><name>Rectangle2D</name></type> <name>plotArea</name></decl></param>, 
                            <param><decl><type><name>Arc2D</name></type> <name>arc</name></decl></param>, 
                            <param><decl><type><name>Area</name></type> <name>front</name></decl></param>, 
                            <param><decl><type><name>Area</name></type> <name>back</name></decl></param>,
                            <param><decl><type><name>Paint</name></type> <name>paint</name></decl></param>, 
                            <param><decl><type><name>Paint</name></type> <name>outlinePaint</name></decl></param>,
                            <param><decl><type><name>Stroke</name></type> <name>outlineStroke</name></decl></param>,
                            <param><decl><type><name>boolean</name></type> <name>drawFront</name></decl></param>, 
                            <param><decl><type><name>boolean</name></type> <name>drawBack</name></decl></param>)</parameter_list> <block>{

        <if>if <condition>(<expr><call><name>getDarkerSides</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>paint</name> <name>instanceof</name> <name>Color</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Color</name></type> <name>c</name> =<init> <expr>(<name>Color</name>) <name>paint</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>c</name> = <call><name><name>c</name>.<name>darker</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>paint</name> = <name>c</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <decl_stmt><decl><type><name>double</name></type> <name>start</name> =<init> <expr><call><name><name>arc</name>.<name>getAngleStart</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>extent</name> =<init> <expr><call><name><name>arc</name>.<name>getAngleExtent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>end</name> =<init> <expr><name>start</name> + <name>extent</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>g2</name>.<name>setStroke</name></name><argument_list>(<argument><expr><name>outlineStroke</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="line">// for CLOCKWISE charts, the extent will be negative...</comment>
        <if>if <condition>(<expr><name>extent</name> &lt; 0.0</expr>)</condition><then> <block>{

            <if>if <condition>(<expr><call><name>isAngleAtFront</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// start at front</comment>

                <if>if <condition>(<expr>!<call><name>isAngleAtBack</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

                    <if>if <condition>(<expr><name>extent</name> &gt; -180.0</expr>)</condition><then> <block>{  <comment type="line">// the segment is entirely at the </comment>
                                            <comment type="line">// front of the chart</comment>
                        <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><name>Area</name></type> <name>side</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                    <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>, 
                                    <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call> 
                                    - <call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name><name>side</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then>
                    <else>else <block>{  <comment type="line">// the segment starts at the front, and wraps all </comment>
                            <comment type="line">// the way around</comment>
                            <comment type="line">// the back and finishes at the front again</comment>
                        <decl_stmt><decl><type><name>Area</name></type> <name>side1</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call> - <call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, 
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side1</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <decl_stmt><decl><type><name>Area</name></type> <name>side2</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getMaxX</name></name><argument_list>()</argument_list></call> - <call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name><name>side2</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                    }</block></else></if>
                }</block></then>
                <else>else <block>{  <comment type="line">// starts at the front, finishes at the back (going </comment>
                        <comment type="line">// around the left side)</comment>

                    <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>Area</name></type> <name>side2</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call> - <call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, 
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side2</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>Area</name></type> <name>side1</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call> - <call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side1</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if>
            }</block></then>
            <else>else <block>{  <comment type="line">// the segment starts at the back (still extending </comment>
                    <comment type="line">// CLOCKWISE)</comment>

                <if>if <condition>(<expr>!<call><name>isAngleAtFront</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>extent</name> &gt; -180.0</expr>)</condition><then> <block>{  <comment type="line">// whole segment stays at the back</comment>
                        <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><name>Area</name></type> <name>side</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                    <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call> 
                                    - <call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name><name>side</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then>
                    <else>else <block>{  <comment type="line">// starts at the back, wraps around front, and </comment>
                            <comment type="line">// finishes at back again</comment>
                        <decl_stmt><decl><type><name>Area</name></type> <name>side1</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getMaxX</name></name><argument_list>()</argument_list></call> - <call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side1</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <decl_stmt><decl><type><name>Area</name></type> <name>side2</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call> - <call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name><name>side2</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                    }</block></else></if>
                }</block></then>
                <else>else <block>{  <comment type="line">// starts at back, finishes at front (CLOCKWISE)</comment>

                    <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>Area</name></type> <name>side1</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getMaxX</name></name><argument_list>()</argument_list></call> - <call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side1</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>Area</name></type> <name>side2</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getMaxX</name></name><argument_list>()</argument_list></call> - <call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side2</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                }</block></else></if>
            }</block></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>extent</name> &gt; 0.0</expr>)</condition><then> <block>{  <comment type="line">// the pie sections are arranged ANTICLOCKWISE</comment>

            <if>if <condition>(<expr><call><name>isAngleAtFront</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// segment starts at the front</comment>

                <if>if <condition>(<expr>!<call><name>isAngleAtBack</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// and finishes at the front</comment>

                    <if>if <condition>(<expr><name>extent</name> &lt; 180.0</expr>)</condition><then> <block>{  <comment type="line">// segment only occupies the front</comment>
                        <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><name>Area</name></type> <name>side</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                    <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call> 
                                    - <call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name><name>side</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then>
                    <else>else <block>{  <comment type="line">// segments wraps right around the back...</comment>
                        <decl_stmt><decl><type><name>Area</name></type> <name>side1</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getMaxX</name></name><argument_list>()</argument_list></call> - <call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side1</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <decl_stmt><decl><type><name>Area</name></type> <name>side2</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call> - <call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side2</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                    }</block></else></if>
                }</block></then>
                <else>else <block>{  <comment type="line">// segments starts at front and finishes at back...</comment>
                    <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>Area</name></type> <name>side2</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getMaxX</name></name><argument_list>()</argument_list></call> - <call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side2</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>Area</name></type> <name>side1</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getMaxX</name></name><argument_list>()</argument_list></call> - <call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side1</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if>
            }</block></then>
            <else>else <block>{  <comment type="line">// segment starts at back</comment>

                <if>if <condition>(<expr>!<call><name>isAngleAtFront</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>extent</name> &lt; 180.0</expr>)</condition><then> <block>{  <comment type="line">// and finishes at back</comment>
                        <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><name>Area</name></type> <name>side</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                    <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call> 
                                    - <call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name><name>side</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then>
                    <else>else <block>{  <comment type="line">// starts at back and wraps right around to the </comment>
                            <comment type="line">// back again</comment>
                        <decl_stmt><decl><type><name>Area</name></type> <name>side1</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call> - <call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side1</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <decl_stmt><decl><type><name>Area</name></type> <name>side2</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getMaxX</name></name><argument_list>()</argument_list></call> - <call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side2</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                    }</block></else></if>
                }</block></then>
                <else>else <block>{  <comment type="line">// starts at the back and finishes at the front </comment>
                        <comment type="line">// (wrapping the left side)</comment>
                    <if>if <condition>(<expr><name>drawBack</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>Area</name></type> <name>side1</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>arc</name>.<name>getStartPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call> - <call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side1</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>back</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <if>if <condition>(<expr><name>drawFront</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>Area</name></type> <name>side2</name> =<init> <expr>new <call><name>Area</name><argument_list>(<argument><expr>new <call><name><name>Rectangle2D</name>.<name>Double</name></name><argument_list>(
                                <argument><expr><call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>plotArea</name>.<name>getY</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>arc</name>.<name>getEndPoint</name></name><argument_list>()</argument_list></call>.<call><name>getX</name><argument_list>()</argument_list></call> - <call><name><name>plotArea</name>.<name>getX</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>plotArea</name>.<name>getHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>side2</name>.<name>intersect</name></name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>fill</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>setPaint</name></name><argument_list>(<argument><expr><name>outlinePaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>g2</name>.<name>draw</name></name><argument_list>(<argument><expr><name>side2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if>
            }</block></else></if>

        }</block></then></if></else></if>

    }</block></function>

    <comment type="javadoc">/**
     * Returns a short string describing the type of plot.
     *
     * @return &lt;i&gt;Pie 3D Plot&lt;/i&gt;.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getPlotType</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>localizationResources</name>.<name>getString</name></name><argument_list>(<argument><expr>"Pie_3D_Plot"</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * A utility method that returns true if the angle represents a point at 
     * the front of the 3D pie chart.  0 - 180 degrees is the back, 180 - 360 
     * is the front.
     *
     * @param angle  the angle.
     *
     * @return A boolean.
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isAngleAtFront</name><parameter_list>(<param><decl><type><name>double</name></type> <name>angle</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<call><name><name>Math</name>.<name>sin</name></name><argument_list>(<argument><expr><call><name><name>Math</name>.<name>toRadians</name></name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0.0)</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * A utility method that returns true if the angle represents a point at 
     * the back of the 3D pie chart.  0 - 180 degrees is the back, 180 - 360 
     * is the front.
     *
     * @param angle  the angle.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the angle is at the back of the pie.
     */</comment>
    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isAngleAtBack</name><parameter_list>(<param><decl><type><name>double</name></type> <name>angle</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<call><name><name>Math</name>.<name>sin</name></name><argument_list>(<argument><expr><call><name><name>Math</name>.<name>toRadians</name></name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt; 0.0)</expr>;</return>
    }</block></function>
    
    <comment type="javadoc">/**
     * Tests this plot for equality with an arbitrary object.
     * 
     * @param obj  the object (&lt;code&gt;null&lt;/code&gt; permitted).
     * 
     * @return A boolean.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>obj</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>obj</name> == <name>this</name></expr>)</condition><then> <block>{
            <return>return <expr>true</expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!(<name>obj</name> <name>instanceof</name> <name>PiePlot3D</name>)</expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>PiePlot3D</name></type> <name>that</name> =<init> <expr>(<name>PiePlot3D</name>) <name>obj</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>this</name>.<name>depthFactor</name></name> != <name><name>that</name>.<name>depthFactor</name></name></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>this</name>.<name>darkerSides</name></name> != <name><name>that</name>.<name>darkerSides</name></name></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>super</name>.<name>equals</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

}</block></class>
</unit>
