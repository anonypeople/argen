<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\David\IdeaProjects\arem\resources\systems\ccodec\src\main\java\org\apache\commons\codec\binary\Base32.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>binary</name></name>;</package>

<comment type="javadoc">/**
 * Provides Base32 encoding and decoding as defined by &lt;a href="http://www.ietf.org/rfc/rfc4648.txt"&gt;RFC 4648&lt;/a&gt;.
 *
 * &lt;p&gt;
 * The class can be parameterized in the following manner with various constructors:
 * &lt;ul&gt;
 * &lt;li&gt;Whether to use the "base32hex" variant instead of the default "base32"&lt;/li&gt;
 * &lt;li&gt;Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of
 * 8 in the encoded data.
 * &lt;li&gt;Line separator: Default is CRLF ("\r\n")&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * This class operates directly on byte streams, and not character streams.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This class is thread-safe.
 * &lt;/p&gt;
 *
 * @see &lt;a href="http://www.ietf.org/rfc/rfc4648.txt"&gt;RFC 4648&lt;/a&gt;
 *
 * @since 1.5
 * @version $Id: Base32.java 1488493 2013-06-01 08:43:58Z sebb $
 */</comment>
<class><specifier>public</specifier> class <name>Base32</name> <super><extends>extends <name>BaseNCodec</name></extends></super> <block>{

    <comment type="javadoc">/**
     * BASE32 characters are 5 bits in length.
     * They are formed by taking a block of five octets to form a 40-bit string,
     * which is converted into eight BASE32 characters.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BITS_PER_ENCODED_BYTE</name> =<init> <expr>5</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BYTES_PER_ENCODED_BLOCK</name> =<init> <expr>8</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BYTES_PER_UNENCODED_BLOCK</name> =<init> <expr>5</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Chunk separator per RFC 2045 section 2.1.
     *
     * @see &lt;a href="http://www.ietf.org/rfc/rfc2045.txt"&gt;RFC 2045 section 2.1&lt;/a&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>CHUNK_SEPARATOR</name> =<init> <expr><block>{<expr>'\r'</expr>, <expr>'\n'</expr>}</block></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This array is a lookup table that translates Unicode characters drawn from the "Base32 Alphabet" (as specified
     * in Table 3 of RFC 4648) into their 5-bit positive integer equivalents. Characters that are not in the Base32
     * alphabet but fall within the bounds of the array are translated to -1.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>DECODE_TABLE</name> =<init> <expr><block>{
         <comment type="line">//  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</comment>
            <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <comment type="line">// 00-0f</comment>
            <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <comment type="line">// 10-1f</comment>
            <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <comment type="line">// 20-2f</comment>
            <expr>-1</expr>, <expr>-1</expr>, <expr>26</expr>, <expr>27</expr>, <expr>28</expr>, <expr>29</expr>, <expr>30</expr>, <expr>31</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <comment type="line">// 30-3f 2-7</comment>
            <expr>-1</expr>,  <expr>0</expr>,  <expr>1</expr>,  <expr>2</expr>,  <expr>3</expr>,  <expr>4</expr>,  <expr>5</expr>,  <expr>6</expr>,  <expr>7</expr>,  <expr>8</expr>,  <expr>9</expr>, <expr>10</expr>, <expr>11</expr>, <expr>12</expr>, <expr>13</expr>, <expr>14</expr>, <comment type="line">// 40-4f A-N</comment>
            <expr>15</expr>, <expr>16</expr>, <expr>17</expr>, <expr>18</expr>, <expr>19</expr>, <expr>20</expr>, <expr>21</expr>, <expr>22</expr>, <expr>23</expr>, <expr>24</expr>, <expr>25</expr>,                     <comment type="line">// 50-5a O-Z</comment>
    }</block></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This array is a lookup table that translates 5-bit positive integer index values into their "Base32 Alphabet"
     * equivalents as specified in Table 3 of RFC 4648.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>ENCODE_TABLE</name> =<init> <expr><block>{
            <expr>'A'</expr>, <expr>'B'</expr>, <expr>'C'</expr>, <expr>'D'</expr>, <expr>'E'</expr>, <expr>'F'</expr>, <expr>'G'</expr>, <expr>'H'</expr>, <expr>'I'</expr>, <expr>'J'</expr>, <expr>'K'</expr>, <expr>'L'</expr>, <expr>'M'</expr>,
            <expr>'N'</expr>, <expr>'O'</expr>, <expr>'P'</expr>, <expr>'Q'</expr>, <expr>'R'</expr>, <expr>'S'</expr>, <expr>'T'</expr>, <expr>'U'</expr>, <expr>'V'</expr>, <expr>'W'</expr>, <expr>'X'</expr>, <expr>'Y'</expr>, <expr>'Z'</expr>,
            <expr>'2'</expr>, <expr>'3'</expr>, <expr>'4'</expr>, <expr>'5'</expr>, <expr>'6'</expr>, <expr>'7'</expr>,
    }</block></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This array is a lookup table that translates Unicode characters drawn from the "Base32 |Hex Alphabet" (as
     * specified in Table 3 of RFC 4648) into their 5-bit positive integer equivalents. Characters that are not in the
     * Base32 Hex alphabet but fall within the bounds of the array are translated to -1.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>HEX_DECODE_TABLE</name> =<init> <expr><block>{
         <comment type="line">//  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</comment>
            <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <comment type="line">// 00-0f</comment>
            <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <comment type="line">// 10-1f</comment>
            <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <comment type="line">// 20-2f</comment>
             <expr>0</expr>,  <expr>1</expr>,  <expr>2</expr>,  <expr>3</expr>,  <expr>4</expr>,  <expr>5</expr>,  <expr>6</expr>,  <expr>7</expr>,  <expr>8</expr>,  <expr>9</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <comment type="line">// 30-3f 2-7</comment>
            <expr>-1</expr>, <expr>10</expr>, <expr>11</expr>, <expr>12</expr>, <expr>13</expr>, <expr>14</expr>, <expr>15</expr>, <expr>16</expr>, <expr>17</expr>, <expr>18</expr>, <expr>19</expr>, <expr>20</expr>, <expr>21</expr>, <expr>22</expr>, <expr>23</expr>, <expr>24</expr>, <comment type="line">// 40-4f A-N</comment>
            <expr>25</expr>, <expr>26</expr>, <expr>27</expr>, <expr>28</expr>, <expr>29</expr>, <expr>30</expr>, <expr>31</expr>, <expr>32</expr>,                                 <comment type="line">// 50-57 O-V</comment>
    }</block></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This array is a lookup table that translates 5-bit positive integer index values into their
     * "Base32 Hex Alphabet" equivalents as specified in Table 3 of RFC 4648.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>HEX_ENCODE_TABLE</name> =<init> <expr><block>{
            <expr>'0'</expr>, <expr>'1'</expr>, <expr>'2'</expr>, <expr>'3'</expr>, <expr>'4'</expr>, <expr>'5'</expr>, <expr>'6'</expr>, <expr>'7'</expr>, <expr>'8'</expr>, <expr>'9'</expr>,
            <expr>'A'</expr>, <expr>'B'</expr>, <expr>'C'</expr>, <expr>'D'</expr>, <expr>'E'</expr>, <expr>'F'</expr>, <expr>'G'</expr>, <expr>'H'</expr>, <expr>'I'</expr>, <expr>'J'</expr>, <expr>'K'</expr>, <expr>'L'</expr>, <expr>'M'</expr>,
            <expr>'N'</expr>, <expr>'O'</expr>, <expr>'P'</expr>, <expr>'Q'</expr>, <expr>'R'</expr>, <expr>'S'</expr>, <expr>'T'</expr>, <expr>'U'</expr>, <expr>'V'</expr>,
    }</block></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** Mask used to extract 5 bits, used when encoding Base32 bytes */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MASK_5BITS</name> =<init> <expr>0x1f</expr></init></decl>;</decl_stmt>

    <comment type="line">// The static final fields above are used for the original static byte[] methods on Base32.</comment>
    <comment type="line">// The private member fields below are used with the new streaming approach, which requires</comment>
    <comment type="line">// some state be preserved between calls of encode() and decode().</comment>

    <comment type="javadoc">/**
     * Place holder for the bytes we're dealing with for our based logic.
     * Bitwise operations store and extract the encoding or decoding from this variable.
     */</comment>

    <comment type="javadoc">/**
     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.
     * &lt;code&gt;decodeSize = {@link #BYTES_PER_ENCODED_BLOCK} - 1 + lineSeparator.length;&lt;/code&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>decodeSize</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Decode table to use.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>decodeTable</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.
     * &lt;code&gt;encodeSize = {@link #BYTES_PER_ENCODED_BLOCK} + lineSeparator.length;&lt;/code&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>encodeSize</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Encode table to use.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>encodeTable</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>lineSeparator</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Creates a Base32 codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length is 0 (no chunking).
     * &lt;/p&gt;
     *
     */</comment>
    <constructor><specifier>public</specifier> <name>Base32</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Creates a Base32 codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length is 0 (no chunking).
     * &lt;/p&gt;
     * @param useHex if {@code true} then use Base32 Hex alphabet
     */</comment>
    <constructor><specifier>public</specifier> <name>Base32</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>useHex</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>null</name></expr></argument>, <argument><expr><name>useHex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Creates a Base32 codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length is given in the constructor, the line separator is CRLF.
     * &lt;/p&gt;
     *
     * @param lineLength
     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
     *            decoding.
     */</comment>
    <constructor><specifier>public</specifier> <name>Base32</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>lineLength</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>lineLength</name></expr></argument>, <argument><expr><name>CHUNK_SEPARATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Creates a Base32 codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length and line separator are given in the constructor.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * &lt;/p&gt;
     *
     * @param lineLength
     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
     *            decoding.
     * @param lineSeparator
     *            Each line of encoded data will end with this sequence of bytes.
     * @throws IllegalArgumentException
     *             The provided lineSeparator included some Base32 characters. That's not going to work!
     */</comment>
    <constructor><specifier>public</specifier> <name>Base32</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>lineLength</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>lineSeparator</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>lineLength</name></expr></argument>, <argument><expr><name>lineSeparator</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length and line separator are given in the constructor.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * &lt;/p&gt;
     *
     * @param lineLength
     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
     *            decoding.
     * @param lineSeparator
     *            Each line of encoded data will end with this sequence of bytes.
     * @param useHex
     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
     * @throws IllegalArgumentException
     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the
     *             lineLength &gt; 0 and lineSeparator is null.
     */</comment>
    <constructor><specifier>public</specifier> <name>Base32</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>lineLength</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>lineSeparator</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>useHex</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>BYTES_PER_UNENCODED_BLOCK</name></expr></argument>, <argument><expr><name>BYTES_PER_ENCODED_BLOCK</name></expr></argument>,
                <argument><expr><name>lineLength</name></expr></argument>,
                <argument><expr><name>lineSeparator</name> == <name>null</name> ? 0 : <name><name>lineSeparator</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>useHex</name></expr>)</condition><then><block>{
            <expr_stmt><expr><name><name>this</name>.<name>encodeTable</name></name> = <name>HEX_ENCODE_TABLE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>decodeTable</name></name> = <name>HEX_DECODE_TABLE</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>this</name>.<name>encodeTable</name></name> = <name>ENCODE_TABLE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>decodeTable</name></name> = <name>DECODE_TABLE</name></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr><name>lineLength</name> &gt; 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>lineSeparator</name> == <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"lineLength "+<name>lineLength</name>+" &gt; 0, but lineSeparator is null"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <comment type="line">// Must be done after initializing the tables</comment>
            <if>if <condition>(<expr><call><name>containsAlphabetOrPad</name><argument_list>(<argument><expr><name>lineSeparator</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>sep</name> =<init> <expr><call><name><name>StringUtils</name>.<name>newStringUtf8</name></name><argument_list>(<argument><expr><name>lineSeparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"lineSeparator must not contain Base32 characters: [" + <name>sep</name> + "]"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <expr_stmt><expr><name><name>this</name>.<name>encodeSize</name></name> = <name>BYTES_PER_ENCODED_BLOCK</name> + <name><name>lineSeparator</name>.<name>length</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>lineSeparator</name></name> = new <name><name>byte</name><index>[<expr><name><name>lineSeparator</name>.<name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>lineSeparator</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>this</name>.<name>lineSeparator</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>lineSeparator</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>this</name>.<name>encodeSize</name></name> = <name>BYTES_PER_ENCODED_BLOCK</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>lineSeparator</name></name> = <name>null</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name><name>this</name>.<name>decodeSize</name></name> = <name><name>this</name>.<name>encodeSize</name></name> - 1</expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * &lt;p&gt;
     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
     * with the data to decode, and once with inAvail set to "-1" to alert decoder that EOF has been reached. The "-1"
     * call is not necessary when decoding, but it doesn't hurt, either.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
     * garbage-out philosophy: it will not check the provided data for validity.
     * &lt;/p&gt;
     *
     * @param in
     *            byte[] array of ascii data to Base32 decode.
     * @param inPos
     *            Position to start reading data from.
     * @param inAvail
     *            Amount of bytes available from input for encoding.
     * @param context the context to be used
     *
     * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <name>void</name></type> <name>decode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>in</name></decl></param>, <param><decl><type><name>int</name></type> <name>inPos</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>inAvail</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>Context</name></type> <name>context</name></decl></param>)</parameter_list> <block>{
        <comment type="line">// package protected for access from I/O streams</comment>

        <if>if <condition>(<expr><name><name>context</name>.<name>eof</name></name></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>inAvail</name> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>context</name>.<name>eof</name></name> = true</expr>;</expr_stmt>
        }</block></then></if>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>inAvail</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name></type> <name>b</name> =<init> <expr><name><name>in</name><index>[<expr><name>inPos</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>b</name> == <name>PAD</name></expr>)</condition><then> <block>{
                <comment type="line">// We're done.</comment>
                <expr_stmt><expr><name><name>context</name>.<name>eof</name></name> = true</expr>;</expr_stmt>
                <break>break;</break>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buffer</name> =<init> <expr><call><name>ensureBufferSize</name><argument_list>(<argument><expr><name>decodeSize</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>b</name> &gt;= 0 &amp;&amp; <name>b</name> &lt; <name><name>this</name>.<name>decodeTable</name>.<name>length</name></name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>result</name> =<init> <expr><name><name>this</name>.<name>decodeTable</name><index>[<expr><name>b</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>result</name> &gt;= 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>context</name>.<name>modulus</name></name> = (<name><name>context</name>.<name>modulus</name></name>+1) % <name>BYTES_PER_ENCODED_BLOCK</name></expr>;</expr_stmt>
                        <comment type="line">// collect decoded bytes</comment>
                        <expr_stmt><expr><name><name>context</name>.<name>lbitWorkArea</name></name> = (<name><name>context</name>.<name>lbitWorkArea</name></name> &lt;&lt; <name>BITS_PER_ENCODED_BYTE</name>) + <name>result</name></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name><name>context</name>.<name>modulus</name></name> == 0</expr>)</condition><then> <block>{ <comment type="line">// we can output the 5 bytes</comment>
                            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 32) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 24) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 16) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 8) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then></if>
                }</block></then></if>
            }</block></else></if>
        }</block></for>

        <comment type="line">// Two forms of EOF as far as Base32 decoder is concerned: actual</comment>
        <comment type="line">// EOF (-1) and first time '=' character is encountered in stream.</comment>
        <comment type="line">// This approach makes the '=' padding characters completely optional.</comment>
        <if>if <condition>(<expr><name><name>context</name>.<name>eof</name></name> &amp;&amp; <name><name>context</name>.<name>modulus</name></name> &gt;= 2</expr>)</condition><then> <block>{ <comment type="line">// if modulus &lt; 2, nothing to do</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buffer</name> =<init> <expr><call><name>ensureBufferSize</name><argument_list>(<argument><expr><name>decodeSize</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">//  we ignore partial bytes, i.e. only multiples of 8 count</comment>
            <switch>switch <condition>(<expr><name><name>context</name>.<name>modulus</name></name></expr>)</condition> <block>{
                <case>case <expr>2</expr> : <comment type="line">// 10 bits, drop 2 and output one byte</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 2) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>3</expr> : <comment type="line">// 15 bits, drop 7 and output 1 byte</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 7) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>4</expr> : <comment type="line">// 20 bits = 2*8 + 4</comment>
                    <expr_stmt><expr><name><name>context</name>.<name>lbitWorkArea</name></name> = <name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 4</expr>;</expr_stmt> <comment type="line">// drop 4 bits</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 8) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name>) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>5</expr> : <comment type="line">// 25bits = 3*8 + 1</comment>
                    <expr_stmt><expr><name><name>context</name>.<name>lbitWorkArea</name></name> = <name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 1</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 16) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 8) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name>) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>6</expr> : <comment type="line">// 30bits = 3*8 + 6</comment>
                    <expr_stmt><expr><name><name>context</name>.<name>lbitWorkArea</name></name> = <name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 6</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 16) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 8) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name>) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>7</expr> : <comment type="line">// 35 = 4*8 +3</comment>
                    <expr_stmt><expr><name><name>context</name>.<name>lbitWorkArea</name></name> = <name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 3</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 24) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 16) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 8) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>lbitWorkArea</name></name>) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><default>default:
                    <comment type="line">// modulus can be 0-7, and we excluded 0,1 already</comment>
                    <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Impossible modulus "+<name><name>context</name>.<name>modulus</name></name></expr></argument>)</argument_list></call></expr>;</throw>
            </default>}</block></switch>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * &lt;p&gt;
     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
     * the data to encode, and once with inAvail set to "-1" to alert encoder that EOF has been reached, so flush last
     * remaining bytes (if not multiple of 5).
     * &lt;/p&gt;
     *
     * @param in
     *            byte[] array of binary data to Base32 encode.
     * @param inPos
     *            Position to start reading data from.
     * @param inAvail
     *            Amount of bytes available from input for encoding.
     * @param context the context to be used
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <name>void</name></type> <name>encode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>in</name></decl></param>, <param><decl><type><name>int</name></type> <name>inPos</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>inAvail</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>Context</name></type> <name>context</name></decl></param>)</parameter_list> <block>{
        <comment type="line">// package protected for access from I/O streams</comment>

        <if>if <condition>(<expr><name><name>context</name>.<name>eof</name></name></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <comment type="line">// inAvail &lt; 0 is how we're informed of EOF in the underlying data we're</comment>
        <comment type="line">// encoding.</comment>
        <if>if <condition>(<expr><name>inAvail</name> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>context</name>.<name>eof</name></name> = true</expr>;</expr_stmt>
            <if>if <condition>(<expr>0 == <name><name>context</name>.<name>modulus</name></name> &amp;&amp; <name>lineLength</name> == 0</expr>)</condition><then> <block>{
                <return>return;</return> <comment type="line">// no leftovers to process and not using chunking</comment>
            }</block></then></if>
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buffer</name> =<init> <expr><call><name>ensureBufferSize</name><argument_list>(<argument><expr><name>encodeSize</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>savedPos</name> =<init> <expr><name><name>context</name>.<name>pos</name></name></expr></init></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name><name>context</name>.<name>modulus</name></name></expr>)</condition> <block>{ <comment type="line">// % 5</comment>
                <case>case <expr>0</expr> :
                    <break>break;</break>
                </case><case>case <expr>1</expr> : <comment type="line">// Only 1 octet; take top 5 bits then remainder</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 3</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 8-1*5 = 3</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &lt;&lt; 2</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 5-3=2</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>2</expr> : <comment type="line">// 2 octets = 16 bits to use</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 11</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 16-1*5 = 11</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt;  6</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 16-2*5 = 6</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt;  1</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 16-3*5 = 1</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &lt;&lt;  4</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 5-1 = 4</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>3</expr> : <comment type="line">// 3 octets = 24 bits to use</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 19</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 24-1*5 = 19</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 14</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 24-2*5 = 14</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt;  9</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 24-3*5 = 9</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt;  4</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 24-4*5 = 4</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &lt;&lt;  1</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 5-4 = 1</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>4</expr> : <comment type="line">// 4 octets = 32 bits to use</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 27</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 32-1*5 = 27</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 22</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 32-2*5 = 22</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 17</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 32-3*5 = 17</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 12</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 32-4*5 = 12</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt;  7</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 32-5*5 =  7</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt;  2</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 32-6*5 =  2</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &lt;&lt;  3</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// 5-2 = 3</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    <break>break;</break>
                </case><default>default:
                    <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Impossible modulus "+<name><name>context</name>.<name>modulus</name></name></expr></argument>)</argument_list></call></expr>;</throw>
            </default>}</block></switch>
            <expr_stmt><expr><name><name>context</name>.<name>currentLinePos</name></name> += <name><name>context</name>.<name>pos</name></name> - <name>savedPos</name></expr>;</expr_stmt> <comment type="line">// keep track of current line position</comment>
            <comment type="line">// if currentPos == 0 we are at the start of a line, so don't add CRLF</comment>
            <if>if <condition>(<expr><name>lineLength</name> &gt; 0 &amp;&amp; <name><name>context</name>.<name>currentLinePos</name></name> &gt; 0</expr>)</condition><then><block>{ <comment type="line">// add chunk separator if required</comment>
                <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>lineSeparator</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>context</name>.<name>pos</name></name></expr></argument>, <argument><expr><name><name>lineSeparator</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>context</name>.<name>pos</name></name> += <name><name>lineSeparator</name>.<name>length</name></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>inAvail</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buffer</name> =<init> <expr><call><name>ensureBufferSize</name><argument_list>(<argument><expr><name>encodeSize</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>context</name>.<name>modulus</name></name> = (<name><name>context</name>.<name>modulus</name></name>+1) % <name>BYTES_PER_UNENCODED_BLOCK</name></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>b</name> =<init> <expr><name><name>in</name><index>[<expr><name>inPos</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>b</name> &lt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>b</name> += 256</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name><name>context</name>.<name>lbitWorkArea</name></name> = (<name><name>context</name>.<name>lbitWorkArea</name></name> &lt;&lt; 8) + <name>b</name></expr>;</expr_stmt> <comment type="line">// BITS_PER_BYTE</comment>
                <if>if <condition>(<expr>0 == <name><name>context</name>.<name>modulus</name></name></expr>)</condition><then> <block>{ <comment type="line">// we have enough bytes to create our output</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 35</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 30</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 25</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 20</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 15</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 10</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>context</name>.<name>lbitWorkArea</name></name> &gt;&gt; 5</expr></argument>)</argument_list></call> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr>(<name>int</name>)<name><name>context</name>.<name>lbitWorkArea</name></name> &amp; <name>MASK_5BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>context</name>.<name>currentLinePos</name></name> += <name>BYTES_PER_ENCODED_BLOCK</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>lineLength</name> &gt; 0 &amp;&amp; <name>lineLength</name> &lt;= <name><name>context</name>.<name>currentLinePos</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>lineSeparator</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>context</name>.<name>pos</name></name></expr></argument>, <argument><expr><name><name>lineSeparator</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>context</name>.<name>pos</name></name> += <name><name>lineSeparator</name>.<name>length</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>context</name>.<name>currentLinePos</name></name> = 0</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
            }</block></for>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Returns whether or not the &lt;code&gt;octet&lt;/code&gt; is in the Base32 alphabet.
     *
     * @param octet
     *            The value to test
     * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>isInAlphabet</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>byte</name></type> <name>octet</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name>octet</name> &gt;= 0 &amp;&amp; <name>octet</name> &lt; <name><name>decodeTable</name>.<name>length</name></name> &amp;&amp; <name><name>decodeTable</name><index>[<expr><name>octet</name></expr>]</index></name> != -1</expr>;</return>
    }</block></function>
}</block></class>
</unit>
