<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\David\IdeaProjects\arem\resources\systems\ccodec\src\main\java\org\apache\commons\codec\binary\Base64.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>binary</name></name>;</package>

<import>import <name><name>java</name>.<name>math</name>.<name>BigInteger</name></name>;</import>

<comment type="javadoc">/**
 * Provides Base64 encoding and decoding as defined by &lt;a href="http://www.ietf.org/rfc/rfc2045.txt"&gt;RFC 2045&lt;/a&gt;.
 *
 * &lt;p&gt;
 * This class implements section &lt;cite&gt;6.8. Base64 Content-Transfer-Encoding&lt;/cite&gt; from RFC 2045 &lt;cite&gt;Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&lt;/cite&gt; by Freed and Borenstein.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The class can be parameterized in the following manner with various constructors:
 * &lt;ul&gt;
 * &lt;li&gt;URL-safe mode: Default off.&lt;/li&gt;
 * &lt;li&gt;Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of
 * 4 in the encoded data.
 * &lt;li&gt;Line separator: Default is CRLF ("\r\n")&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only
 * encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252,
 * UTF-8, etc).
 * &lt;/p&gt;
 * &lt;p&gt;
 * This class is thread-safe.
 * &lt;/p&gt;
 *
 * @see &lt;a href="http://www.ietf.org/rfc/rfc2045.txt"&gt;RFC 2045&lt;/a&gt;
 * @since 1.0
 * @version $Id: Base64.java 1447577 2013-02-19 02:45:18Z julius $
 */</comment>
<class><specifier>public</specifier> class <name>Base64</name> <super><extends>extends <name>BaseNCodec</name></extends></super> <block>{

    <comment type="javadoc">/**
     * BASE32 characters are 6 bits in length.
     * They are formed by taking a block of 3 octets to form a 24-bit string,
     * which is converted into 4 BASE64 characters.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BITS_PER_ENCODED_BYTE</name> =<init> <expr>6</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BYTES_PER_UNENCODED_BLOCK</name> =<init> <expr>3</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BYTES_PER_ENCODED_BLOCK</name> =<init> <expr>4</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Chunk separator per RFC 2045 section 2.1.
     *
     * &lt;p&gt;
     * N.B. The next major release may break compatibility and make this field private.
     * &lt;/p&gt;
     *
     * @see &lt;a href="http://www.ietf.org/rfc/rfc2045.txt"&gt;RFC 2045 section 2.1&lt;/a&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>CHUNK_SEPARATOR</name> =<init> <expr><block>{<expr>'\r'</expr>, <expr>'\n'</expr>}</block></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This array is a lookup table that translates 6-bit positive integer index values into their "Base64 Alphabet"
     * equivalents as specified in Table 1 of RFC 2045.
     *
     * Thanks to "commons" project in ws.apache.org for this code.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>STANDARD_ENCODE_TABLE</name> =<init> <expr><block>{
            <expr>'A'</expr>, <expr>'B'</expr>, <expr>'C'</expr>, <expr>'D'</expr>, <expr>'E'</expr>, <expr>'F'</expr>, <expr>'G'</expr>, <expr>'H'</expr>, <expr>'I'</expr>, <expr>'J'</expr>, <expr>'K'</expr>, <expr>'L'</expr>, <expr>'M'</expr>,
            <expr>'N'</expr>, <expr>'O'</expr>, <expr>'P'</expr>, <expr>'Q'</expr>, <expr>'R'</expr>, <expr>'S'</expr>, <expr>'T'</expr>, <expr>'U'</expr>, <expr>'V'</expr>, <expr>'W'</expr>, <expr>'X'</expr>, <expr>'Y'</expr>, <expr>'Z'</expr>,
            <expr>'a'</expr>, <expr>'b'</expr>, <expr>'c'</expr>, <expr>'d'</expr>, <expr>'e'</expr>, <expr>'f'</expr>, <expr>'g'</expr>, <expr>'h'</expr>, <expr>'i'</expr>, <expr>'j'</expr>, <expr>'k'</expr>, <expr>'l'</expr>, <expr>'m'</expr>,
            <expr>'n'</expr>, <expr>'o'</expr>, <expr>'p'</expr>, <expr>'q'</expr>, <expr>'r'</expr>, <expr>'s'</expr>, <expr>'t'</expr>, <expr>'u'</expr>, <expr>'v'</expr>, <expr>'w'</expr>, <expr>'x'</expr>, <expr>'y'</expr>, <expr>'z'</expr>,
            <expr>'0'</expr>, <expr>'1'</expr>, <expr>'2'</expr>, <expr>'3'</expr>, <expr>'4'</expr>, <expr>'5'</expr>, <expr>'6'</expr>, <expr>'7'</expr>, <expr>'8'</expr>, <expr>'9'</expr>, <expr>'+'</expr>, <expr>'/'</expr>
    }</block></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /
     * changed to - and _ to make the encoded Base64 results more URL-SAFE.
     * This table is only used when the Base64's mode is set to URL-SAFE.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>URL_SAFE_ENCODE_TABLE</name> =<init> <expr><block>{
            <expr>'A'</expr>, <expr>'B'</expr>, <expr>'C'</expr>, <expr>'D'</expr>, <expr>'E'</expr>, <expr>'F'</expr>, <expr>'G'</expr>, <expr>'H'</expr>, <expr>'I'</expr>, <expr>'J'</expr>, <expr>'K'</expr>, <expr>'L'</expr>, <expr>'M'</expr>,
            <expr>'N'</expr>, <expr>'O'</expr>, <expr>'P'</expr>, <expr>'Q'</expr>, <expr>'R'</expr>, <expr>'S'</expr>, <expr>'T'</expr>, <expr>'U'</expr>, <expr>'V'</expr>, <expr>'W'</expr>, <expr>'X'</expr>, <expr>'Y'</expr>, <expr>'Z'</expr>,
            <expr>'a'</expr>, <expr>'b'</expr>, <expr>'c'</expr>, <expr>'d'</expr>, <expr>'e'</expr>, <expr>'f'</expr>, <expr>'g'</expr>, <expr>'h'</expr>, <expr>'i'</expr>, <expr>'j'</expr>, <expr>'k'</expr>, <expr>'l'</expr>, <expr>'m'</expr>,
            <expr>'n'</expr>, <expr>'o'</expr>, <expr>'p'</expr>, <expr>'q'</expr>, <expr>'r'</expr>, <expr>'s'</expr>, <expr>'t'</expr>, <expr>'u'</expr>, <expr>'v'</expr>, <expr>'w'</expr>, <expr>'x'</expr>, <expr>'y'</expr>, <expr>'z'</expr>,
            <expr>'0'</expr>, <expr>'1'</expr>, <expr>'2'</expr>, <expr>'3'</expr>, <expr>'4'</expr>, <expr>'5'</expr>, <expr>'6'</expr>, <expr>'7'</expr>, <expr>'8'</expr>, <expr>'9'</expr>, <expr>'-'</expr>, <expr>'_'</expr>
    }</block></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * This array is a lookup table that translates Unicode characters drawn from the "Base64 Alphabet" (as specified
     * in Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64
     * alphabet but fall within the bounds of the array are translated to -1.
     *
     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both
     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).
     *
     * Thanks to "commons" project in ws.apache.org for this code.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>DECODE_TABLE</name> =<init> <expr><block>{
            <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
            <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
            <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>62</expr>, <expr>-1</expr>, <expr>62</expr>, <expr>-1</expr>, <expr>63</expr>, <expr>52</expr>, <expr>53</expr>, <expr>54</expr>,
            <expr>55</expr>, <expr>56</expr>, <expr>57</expr>, <expr>58</expr>, <expr>59</expr>, <expr>60</expr>, <expr>61</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>, <expr>4</expr>,
            <expr>5</expr>, <expr>6</expr>, <expr>7</expr>, <expr>8</expr>, <expr>9</expr>, <expr>10</expr>, <expr>11</expr>, <expr>12</expr>, <expr>13</expr>, <expr>14</expr>, <expr>15</expr>, <expr>16</expr>, <expr>17</expr>, <expr>18</expr>, <expr>19</expr>, <expr>20</expr>, <expr>21</expr>, <expr>22</expr>, <expr>23</expr>,
            <expr>24</expr>, <expr>25</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>63</expr>, <expr>-1</expr>, <expr>26</expr>, <expr>27</expr>, <expr>28</expr>, <expr>29</expr>, <expr>30</expr>, <expr>31</expr>, <expr>32</expr>, <expr>33</expr>, <expr>34</expr>,
            <expr>35</expr>, <expr>36</expr>, <expr>37</expr>, <expr>38</expr>, <expr>39</expr>, <expr>40</expr>, <expr>41</expr>, <expr>42</expr>, <expr>43</expr>, <expr>44</expr>, <expr>45</expr>, <expr>46</expr>, <expr>47</expr>, <expr>48</expr>, <expr>49</expr>, <expr>50</expr>, <expr>51</expr>
    }</block></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Base64 uses 6-bit fields.
     */</comment>
    <comment type="javadoc">/** Mask used to extract 6 bits, used when encoding */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MASK_6BITS</name> =<init> <expr>0x3f</expr></init></decl>;</decl_stmt>

    <comment type="line">// The static final fields above are used for the original static byte[] methods on Base64.</comment>
    <comment type="line">// The private member fields below are used with the new streaming approach, which requires</comment>
    <comment type="line">// some state be preserved between calls of encode() and decode().</comment>

    <comment type="javadoc">/**
     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able
     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch
     * between the two modes.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>encodeTable</name></decl>;</decl_stmt>

    <comment type="line">// Only one decode table currently; keep for consistency with Base32 code</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>decodeTable</name> =<init> <expr><name>DECODE_TABLE</name></expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>lineSeparator</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.
     * &lt;code&gt;decodeSize = 3 + lineSeparator.length;&lt;/code&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>decodeSize</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.
     * &lt;code&gt;encodeSize = 4 + lineSeparator.length;&lt;/code&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>encodeSize</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
     * &lt;p&gt;
     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When decoding all variants are supported.
     * &lt;/p&gt;
     */</comment>
    <constructor><specifier>public</specifier> <name>Base64</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.
     * &lt;p&gt;
     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is
     * STANDARD_ENCODE_TABLE.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When decoding all variants are supported.
     * &lt;/p&gt;
     *
     * @param urlSafe
     *            if {@code true}, URL-safe encoding is used. In most cases this should be set to {@code false}.
     * @since 1.4
     */</comment>
    <constructor><specifier>public</specifier> <name>Base64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>urlSafe</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>MIME_CHUNK_SIZE</name></expr></argument>, <argument><expr><name>CHUNK_SEPARATOR</name></expr></argument>, <argument><expr><name>urlSafe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
     * &lt;p&gt;
     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
     * STANDARD_ENCODE_TABLE.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
     * &lt;/p&gt;
     * &lt;p&gt;
     * When decoding all variants are supported.
     * &lt;/p&gt;
     *
     * @param lineLength
     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
     *            decoding.
     * @since 1.4
     */</comment>
    <constructor><specifier>public</specifier> <name>Base64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>lineLength</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>lineLength</name></expr></argument>, <argument><expr><name>CHUNK_SEPARATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
     * &lt;p&gt;
     * When encoding the line length and line separator are given in the constructor, and the encoding table is
     * STANDARD_ENCODE_TABLE.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
     * &lt;/p&gt;
     * &lt;p&gt;
     * When decoding all variants are supported.
     * &lt;/p&gt;
     *
     * @param lineLength
     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
     *            decoding.
     * @param lineSeparator
     *            Each line of encoded data will end with this sequence of bytes.
     * @throws IllegalArgumentException
     *             Thrown when the provided lineSeparator included some base64 characters.
     * @since 1.4
     */</comment>
    <constructor><specifier>public</specifier> <name>Base64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>lineLength</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>lineSeparator</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>lineLength</name></expr></argument>, <argument><expr><name>lineSeparator</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
     * &lt;p&gt;
     * When encoding the line length and line separator are given in the constructor, and the encoding table is
     * STANDARD_ENCODE_TABLE.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
     * &lt;/p&gt;
     * &lt;p&gt;
     * When decoding all variants are supported.
     * &lt;/p&gt;
     *
     * @param lineLength
     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of
     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
     *            decoding.
     * @param lineSeparator
     *            Each line of encoded data will end with this sequence of bytes.
     * @param urlSafe
     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode
     *            operations. Decoding seamlessly handles both modes.
     *            &lt;b&gt;Note: no padding is added when using the URL-safe alphabet.&lt;/b&gt;
     * @throws IllegalArgumentException
     *             The provided lineSeparator included some base64 characters. That's not going to work!
     * @since 1.4
     */</comment>
    <constructor><specifier>public</specifier> <name>Base64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>lineLength</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>lineSeparator</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>urlSafe</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>BYTES_PER_UNENCODED_BLOCK</name></expr></argument>, <argument><expr><name>BYTES_PER_ENCODED_BLOCK</name></expr></argument>,
                <argument><expr><name>lineLength</name></expr></argument>,
                <argument><expr><name>lineSeparator</name> == <name>null</name> ? 0 : <name><name>lineSeparator</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// TODO could be simplified if there is no requirement to reject invalid line sep when length &lt;=0</comment>
        <comment type="line">// @see test case Base64Test.testConstructors()</comment>
        <if>if <condition>(<expr><name>lineSeparator</name> != <name>null</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>containsAlphabetOrPad</name><argument_list>(<argument><expr><name>lineSeparator</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>sep</name> =<init> <expr><call><name><name>StringUtils</name>.<name>newStringUtf8</name></name><argument_list>(<argument><expr><name>lineSeparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"lineSeparator must not contain base64 characters: [" + <name>sep</name> + "]"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <if>if <condition>(<expr><name>lineLength</name> &gt; 0</expr>)</condition><then><block>{ <comment type="line">// null line-sep forces no chunking rather than throwing IAE</comment>
                <expr_stmt><expr><name><name>this</name>.<name>encodeSize</name></name> = <name>BYTES_PER_ENCODED_BLOCK</name> + <name><name>lineSeparator</name>.<name>length</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>lineSeparator</name></name> = new <name><name>byte</name><index>[<expr><name><name>lineSeparator</name>.<name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>lineSeparator</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>this</name>.<name>lineSeparator</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>lineSeparator</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name><name>this</name>.<name>encodeSize</name></name> = <name>BYTES_PER_ENCODED_BLOCK</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name>.<name>lineSeparator</name></name> = <name>null</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>this</name>.<name>encodeSize</name></name> = <name>BYTES_PER_ENCODED_BLOCK</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>lineSeparator</name></name> = <name>null</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name><name>this</name>.<name>decodeSize</name></name> = <name><name>this</name>.<name>encodeSize</name></name> - 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>encodeTable</name></name> = <name>urlSafe</name> ? <name>URL_SAFE_ENCODE_TABLE</name> : <name>STANDARD_ENCODE_TABLE</name></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.
     *
     * @return true if we're in URL-SAFE mode, false otherwise.
     * @since 1.4
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isUrlSafe</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>encodeTable</name></name> == <name>URL_SAFE_ENCODE_TABLE</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * &lt;p&gt;
     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
     * the data to encode, and once with inAvail set to "-1" to alert encoder that EOF has been reached, to flush last
     * remaining bytes (if not multiple of 3).
     * &lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Note: no padding is added when encoding using the URL-safe alphabet.&lt;/b&gt;&lt;/p&gt;
     * &lt;p&gt;
     * Thanks to "commons" project in ws.apache.org for the bitwise operations, and general approach.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * &lt;/p&gt;
     *
     * @param in
     *            byte[] array of binary data to base64 encode.
     * @param inPos
     *            Position to start reading data from.
     * @param inAvail
     *            Amount of bytes available from input for encoding.
     * @param context
     *            the context to be used
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <name>void</name></type> <name>encode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>in</name></decl></param>, <param><decl><type><name>int</name></type> <name>inPos</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>inAvail</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>Context</name></type> <name>context</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>context</name>.<name>eof</name></name></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <comment type="line">// inAvail &lt; 0 is how we're informed of EOF in the underlying data we're</comment>
        <comment type="line">// encoding.</comment>
        <if>if <condition>(<expr><name>inAvail</name> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>context</name>.<name>eof</name></name> = true</expr>;</expr_stmt>
            <if>if <condition>(<expr>0 == <name><name>context</name>.<name>modulus</name></name> &amp;&amp; <name>lineLength</name> == 0</expr>)</condition><then> <block>{
                <return>return;</return> <comment type="line">// no leftovers to process and not using chunking</comment>
            }</block></then></if>
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buffer</name> =<init> <expr><call><name>ensureBufferSize</name><argument_list>(<argument><expr><name>encodeSize</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>savedPos</name> =<init> <expr><name><name>context</name>.<name>pos</name></name></expr></init></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name><name>context</name>.<name>modulus</name></name></expr>)</condition> <block>{ <comment type="line">// 0-2</comment>
                <case>case <expr>0</expr> : <comment type="line">// nothing to do here</comment>
                    <break>break;</break>
                </case><case>case <expr>1</expr> : <comment type="line">// 8 bits = 6 + 2</comment>
                    <comment type="line">// top 6 bits:</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr>(<name><name>context</name>.<name>ibitWorkArea</name></name> &gt;&gt; 2) &amp; <name>MASK_6BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <comment type="line">// remaining 2:</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr>(<name><name>context</name>.<name>ibitWorkArea</name></name> &lt;&lt; 4) &amp; <name>MASK_6BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <comment type="line">// URL-SAFE skips the padding to further reduce size.</comment>
                    <if>if <condition>(<expr><name>encodeTable</name> == <name>STANDARD_ENCODE_TABLE</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    }</block></then></if>
                    <break>break;</break>

                </case><case>case <expr>2</expr> : <comment type="line">// 16 bits = 6 + 6 + 4</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr>(<name><name>context</name>.<name>ibitWorkArea</name></name> &gt;&gt; 10) &amp; <name>MASK_6BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr>(<name><name>context</name>.<name>ibitWorkArea</name></name> &gt;&gt; 4) &amp; <name>MASK_6BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr>(<name><name>context</name>.<name>ibitWorkArea</name></name> &lt;&lt; 2) &amp; <name>MASK_6BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <comment type="line">// URL-SAFE skips the padding to further reduce size.</comment>
                    <if>if <condition>(<expr><name>encodeTable</name> == <name>STANDARD_ENCODE_TABLE</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name>PAD</name></expr>;</expr_stmt>
                    }</block></then></if>
                    <break>break;</break>
                </case><default>default:
                    <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Impossible modulus "+<name><name>context</name>.<name>modulus</name></name></expr></argument>)</argument_list></call></expr>;</throw>
            </default>}</block></switch>
            <expr_stmt><expr><name><name>context</name>.<name>currentLinePos</name></name> += <name><name>context</name>.<name>pos</name></name> - <name>savedPos</name></expr>;</expr_stmt> <comment type="line">// keep track of current line position</comment>
            <comment type="line">// if currentPos == 0 we are at the start of a line, so don't add CRLF</comment>
            <if>if <condition>(<expr><name>lineLength</name> &gt; 0 &amp;&amp; <name><name>context</name>.<name>currentLinePos</name></name> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>lineSeparator</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>context</name>.<name>pos</name></name></expr></argument>, <argument><expr><name><name>lineSeparator</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>context</name>.<name>pos</name></name> += <name><name>lineSeparator</name>.<name>length</name></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>inAvail</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buffer</name> =<init> <expr><call><name>ensureBufferSize</name><argument_list>(<argument><expr><name>encodeSize</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>context</name>.<name>modulus</name></name> = (<name><name>context</name>.<name>modulus</name></name>+1) % <name>BYTES_PER_UNENCODED_BLOCK</name></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>b</name> =<init> <expr><name><name>in</name><index>[<expr><name>inPos</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>b</name> &lt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>b</name> += 256</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name><name>context</name>.<name>ibitWorkArea</name></name> = (<name><name>context</name>.<name>ibitWorkArea</name></name> &lt;&lt; 8) + <name>b</name></expr>;</expr_stmt> <comment type="line">//  BITS_PER_BYTE</comment>
                <if>if <condition>(<expr>0 == <name><name>context</name>.<name>modulus</name></name></expr>)</condition><then> <block>{ <comment type="line">// 3 bytes = 24 bits = 4 * 6 bits to extract</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr>(<name><name>context</name>.<name>ibitWorkArea</name></name> &gt;&gt; 18) &amp; <name>MASK_6BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr>(<name><name>context</name>.<name>ibitWorkArea</name></name> &gt;&gt; 12) &amp; <name>MASK_6BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr>(<name><name>context</name>.<name>ibitWorkArea</name></name> &gt;&gt; 6) &amp; <name>MASK_6BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <name><name>encodeTable</name><index>[<expr><name><name>context</name>.<name>ibitWorkArea</name></name> &amp; <name>MASK_6BITS</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>context</name>.<name>currentLinePos</name></name> += <name>BYTES_PER_ENCODED_BLOCK</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>lineLength</name> &gt; 0 &amp;&amp; <name>lineLength</name> &lt;= <name><name>context</name>.<name>currentLinePos</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>lineSeparator</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>context</name>.<name>pos</name></name></expr></argument>, <argument><expr><name><name>lineSeparator</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>context</name>.<name>pos</name></name> += <name><name>lineSeparator</name>.<name>length</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>context</name>.<name>currentLinePos</name></name> = 0</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
            }</block></for>
        }</block></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * &lt;p&gt;
     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
     * with the data to decode, and once with inAvail set to "-1" to alert decoder that EOF has been reached. The "-1"
     * call is not necessary when decoding, but it doesn't hurt, either.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
     * garbage-out philosophy: it will not check the provided data for validity.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Thanks to "commons" project in ws.apache.org for the bitwise operations, and general approach.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * &lt;/p&gt;
     *
     * @param in
     *            byte[] array of ascii data to base64 decode.
     * @param inPos
     *            Position to start reading data from.
     * @param inAvail
     *            Amount of bytes available from input for encoding.
     * @param context
     *            the context to be used
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <name>void</name></type> <name>decode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>in</name></decl></param>, <param><decl><type><name>int</name></type> <name>inPos</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>inAvail</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>Context</name></type> <name>context</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>context</name>.<name>eof</name></name></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>inAvail</name> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>context</name>.<name>eof</name></name> = true</expr>;</expr_stmt>
        }</block></then></if>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>inAvail</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buffer</name> =<init> <expr><call><name>ensureBufferSize</name><argument_list>(<argument><expr><name>decodeSize</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name></type> <name>b</name> =<init> <expr><name><name>in</name><index>[<expr><name>inPos</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>b</name> == <name>PAD</name></expr>)</condition><then> <block>{
                <comment type="line">// We're done.</comment>
                <expr_stmt><expr><name><name>context</name>.<name>eof</name></name> = true</expr>;</expr_stmt>
                <break>break;</break>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><name>b</name> &gt;= 0 &amp;&amp; <name>b</name> &lt; <name><name>DECODE_TABLE</name>.<name>length</name></name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>result</name> =<init> <expr><name><name>DECODE_TABLE</name><index>[<expr><name>b</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>result</name> &gt;= 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>context</name>.<name>modulus</name></name> = (<name><name>context</name>.<name>modulus</name></name>+1) % <name>BYTES_PER_ENCODED_BLOCK</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>context</name>.<name>ibitWorkArea</name></name> = (<name><name>context</name>.<name>ibitWorkArea</name></name> &lt;&lt; <name>BITS_PER_ENCODED_BYTE</name>) + <name>result</name></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name><name>context</name>.<name>modulus</name></name> == 0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>ibitWorkArea</name></name> &gt;&gt; 16) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>ibitWorkArea</name></name> &gt;&gt; 8) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name><name>context</name>.<name>ibitWorkArea</name></name> &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then></if>
                }</block></then></if>
            }</block></else></if>
        }</block></for>

        <comment type="line">// Two forms of EOF as far as base64 decoder is concerned: actual</comment>
        <comment type="line">// EOF (-1) and first time '=' character is encountered in stream.</comment>
        <comment type="line">// This approach makes the '=' padding characters completely optional.</comment>
        <if>if <condition>(<expr><name><name>context</name>.<name>eof</name></name> &amp;&amp; <name><name>context</name>.<name>modulus</name></name> != 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buffer</name> =<init> <expr><call><name>ensureBufferSize</name><argument_list>(<argument><expr><name>decodeSize</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// We have some spare bits remaining</comment>
            <comment type="line">// Output all whole multiples of 8 bits and ignore the rest</comment>
            <switch>switch <condition>(<expr><name><name>context</name>.<name>modulus</name></name></expr>)</condition> <block>{
<comment type="line">//              case 0 : // impossible, as excluded above</comment>
                <case>case <expr>1</expr> : <comment type="line">// 6 bits - ignore entirely</comment>
                    <comment type="line">// TODO not currently tested; perhaps it is impossible?</comment>
                    <break>break;</break>
                </case><case>case <expr>2</expr> : <comment type="line">// 12 bits = 8 + 4</comment>
                    <expr_stmt><expr><name><name>context</name>.<name>ibitWorkArea</name></name> = <name><name>context</name>.<name>ibitWorkArea</name></name> &gt;&gt; 4</expr>;</expr_stmt> <comment type="line">// dump the extra 4 bits</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>ibitWorkArea</name></name>) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>3</expr> : <comment type="line">// 18 bits = 8 + 8 + 2</comment>
                    <expr_stmt><expr><name><name>context</name>.<name>ibitWorkArea</name></name> = <name><name>context</name>.<name>ibitWorkArea</name></name> &gt;&gt; 2</expr>;</expr_stmt> <comment type="line">// dump 2 bits</comment>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>ibitWorkArea</name></name> &gt;&gt; 8) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name><name>context</name>.<name>pos</name></name>++</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr>(<name><name>context</name>.<name>ibitWorkArea</name></name>) &amp; <name>MASK_8BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><default>default:
                    <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Impossible modulus "+<name><name>context</name>.<name>modulus</name></name></expr></argument>)</argument_list></call></expr>;</throw>
            </default>}</block></switch>
        }</block></then></if>
    }</block></function>

    <comment type="javadoc">/**
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
     * method treats whitespace as valid.
     *
     * @param arrayOctet
     *            byte array to test
     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
     *         {@code false}, otherwise
     * @deprecated 1.5 Use {@link #isBase64(byte[])}, will be removed in 2.0.
     */</comment>
    <function><type><annotation>@<name>Deprecated</name></annotation>
    <specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isArrayByteBase64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>arrayOctet</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>isBase64</name><argument_list>(<argument><expr><name>arrayOctet</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns whether or not the &lt;code&gt;octet&lt;/code&gt; is in the base 64 alphabet.
     *
     * @param octet
     *            The value to test
     * @return {@code true} if the value is defined in the the base 64 alphabet, {@code false} otherwise.
     * @since 1.4
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isBase64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>byte</name></type> <name>octet</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name>octet</name> == <name>PAD_DEFAULT</name> || (<name>octet</name> &gt;= 0 &amp;&amp; <name>octet</name> &lt; <name><name>DECODE_TABLE</name>.<name>length</name></name> &amp;&amp; <name><name>DECODE_TABLE</name><index>[<expr><name>octet</name></expr>]</index></name> != -1)</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the
     * method treats whitespace as valid.
     *
     * @param base64
     *            String to test
     * @return {@code true} if all characters in the String are valid characters in the Base64 alphabet or if
     *         the String is empty; {@code false}, otherwise
     *  @since 1.5
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isBase64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>base64</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>isBase64</name><argument_list>(<argument><expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>base64</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
     * method treats whitespace as valid.
     *
     * @param arrayOctet
     *            byte array to test
     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
     *         {@code false}, otherwise
     * @since 1.5
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isBase64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>arrayOctet</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>arrayOctet</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr>!<call><name>isBase64</name><argument_list>(<argument><expr><name><name>arrayOctet</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>isWhiteSpace</name><argument_list>(<argument><expr><name><name>arrayOctet</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes binary data using the base64 algorithm but does not chunk the output.
     *
     * @param binaryData
     *            binary data to encode
     * @return byte[] containing Base64 characters in their UTF-8 representation.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>encodeBase64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>binaryData</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>encodeBase64</name><argument_list>(<argument><expr><name>binaryData</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes binary data using the base64 algorithm but does not chunk the output.
     *
     * NOTE:  We changed the behaviour of this method from multi-line chunking (commons-codec-1.4) to
     * single-line non-chunking (commons-codec-1.5).
     *
     * @param binaryData
     *            binary data to encode
     * @return String containing Base64 characters.
     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>encodeBase64String</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>binaryData</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>StringUtils</name>.<name>newStringUtf8</name></name><argument_list>(<argument><expr><call><name>encodeBase64</name><argument_list>(<argument><expr><name>binaryData</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
     * url-safe variation emits - and _ instead of + and / characters.
     * &lt;b&gt;Note: no padding is added.&lt;/b&gt;
     * @param binaryData
     *            binary data to encode
     * @return byte[] containing Base64 characters in their UTF-8 representation.
     * @since 1.4
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>encodeBase64URLSafe</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>binaryData</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>encodeBase64</name><argument_list>(<argument><expr><name>binaryData</name></expr></argument>, <argument><expr>false</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
     * url-safe variation emits - and _ instead of + and / characters.
     * &lt;b&gt;Note: no padding is added.&lt;/b&gt;
     * @param binaryData
     *            binary data to encode
     * @return String containing Base64 characters
     * @since 1.4
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>encodeBase64URLSafeString</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>binaryData</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>StringUtils</name>.<name>newStringUtf8</name></name><argument_list>(<argument><expr><call><name>encodeBase64</name><argument_list>(<argument><expr><name>binaryData</name></expr></argument>, <argument><expr>false</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
     *
     * @param binaryData
     *            binary data to encode
     * @return Base64 characters chunked in 76 character blocks
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>encodeBase64Chunked</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>binaryData</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>encodeBase64</name><argument_list>(<argument><expr><name>binaryData</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
     *
     * @param binaryData
     *            Array containing binary data to encode.
     * @param isChunked
     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks
     * @return Base64-encoded data.
     * @throws IllegalArgumentException
     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>encodeBase64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>binaryData</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>isChunked</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>encodeBase64</name><argument_list>(<argument><expr><name>binaryData</name></expr></argument>, <argument><expr><name>isChunked</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
     *
     * @param binaryData
     *            Array containing binary data to encode.
     * @param isChunked
     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks
     * @param urlSafe
     *            if {@code true} this encoder will emit - and _ instead of the usual + and / characters.
     *            &lt;b&gt;Note: no padding is added when encoding using the URL-safe alphabet.&lt;/b&gt;
     * @return Base64-encoded data.
     * @throws IllegalArgumentException
     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
     * @since 1.4
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>encodeBase64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>binaryData</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>isChunked</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>urlSafe</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>encodeBase64</name><argument_list>(<argument><expr><name>binaryData</name></expr></argument>, <argument><expr><name>isChunked</name></expr></argument>, <argument><expr><name>urlSafe</name></expr></argument>, <argument><expr><name><name>Integer</name>.<name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
     *
     * @param binaryData
     *            Array containing binary data to encode.
     * @param isChunked
     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks
     * @param urlSafe
     *            if {@code true} this encoder will emit - and _ instead of the usual + and / characters.
     *            &lt;b&gt;Note: no padding is added when encoding using the URL-safe alphabet.&lt;/b&gt;
     * @param maxResultSize
     *            The maximum result size to accept.
     * @return Base64-encoded data.
     * @throws IllegalArgumentException
     *             Thrown when the input array needs an output array bigger than maxResultSize
     * @since 1.4
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>encodeBase64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>binaryData</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>isChunked</name></decl></param>,
                                      <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>urlSafe</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxResultSize</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>binaryData</name> == <name>null</name> || <name><name>binaryData</name>.<name>length</name></name> == 0</expr>)</condition><then> <block>{
            <return>return <expr><name>binaryData</name></expr>;</return>
        }</block></then></if>

        <comment type="line">// Create this so can use the super-class method</comment>
        <comment type="line">// Also ensures that the same roundings are performed by the ctor and the code</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64</name></type> <name>b64</name> =<init> <expr><name>isChunked</name> ? new <call><name>Base64</name><argument_list>(<argument><expr><name>urlSafe</name></expr></argument>)</argument_list></call> : new <call><name>Base64</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>CHUNK_SEPARATOR</name></expr></argument>, <argument><expr><name>urlSafe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>len</name> =<init> <expr><call><name><name>b64</name>.<name>getEncodedLength</name></name><argument_list>(<argument><expr><name>binaryData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> &gt; <name>maxResultSize</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Input array too big, the output array would be bigger (" +
                <name>len</name> +
                ") than the specified maximum size of " +
                <name>maxResultSize</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <return>return <expr><call><name><name>b64</name>.<name>encode</name></name><argument_list>(<argument><expr><name>binaryData</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Decodes a Base64 String into octets
     *
     * @param base64String
     *            String containing Base64 data
     * @return Array containing decoded data.
     * @since 1.4
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>decodeBase64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>base64String</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>new <call><name>Base64</name><argument_list>()</argument_list></call>.<call><name>decode</name><argument_list>(<argument><expr><name>base64String</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Decodes Base64 data into octets
     *
     * @param base64Data
     *            Byte array containing Base64 data
     * @return Array containing decoded data.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>decodeBase64</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>base64Data</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>new <call><name>Base64</name><argument_list>()</argument_list></call>.<call><name>decode</name><argument_list>(<argument><expr><name>base64Data</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Implementation of the Encoder Interface</comment>

    <comment type="line">// Implementation of integer encoding used for crypto</comment>
    <comment type="javadoc">/**
     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature
     *
     * @param pArray
     *            a byte array containing base64 character data
     * @return A BigInteger
     * @since 1.4
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>BigInteger</name></type> <name>decodeInteger</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>pArray</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>new <call><name>BigInteger</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>decodeBase64</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature
     *
     * @param bigInt
     *            a BigInteger
     * @return A byte array containing base64 character data
     * @throws NullPointerException
     *             if null is passed in
     * @since 1.4
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>encodeInteger</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>BigInteger</name></type> <name>bigInt</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>bigInt</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>NullPointerException</name><argument_list>(<argument><expr>"encodeInteger called with null parameter"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name>encodeBase64</name><argument_list>(<argument><expr><call><name>toIntegerBytes</name><argument_list>(<argument><expr><name>bigInt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns a byte-array representation of a &lt;code&gt;BigInteger&lt;/code&gt; without sign bit.
     *
     * @param bigInt
     *            &lt;code&gt;BigInteger&lt;/code&gt; to be converted
     * @return a byte array representation of the BigInteger parameter
     */</comment>
    <function><type><specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>toIntegerBytes</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>BigInteger</name></type> <name>bigInt</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>bitlen</name> =<init> <expr><call><name><name>bigInt</name>.<name>bitLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// round bitlen</comment>
        <expr_stmt><expr><name>bitlen</name> = ((<name>bitlen</name> + 7) &gt;&gt; 3) &lt;&lt; 3</expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>bigBytes</name> =<init> <expr><call><name><name>bigInt</name>.<name>toByteArray</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>((<call><name><name>bigInt</name>.<name>bitLength</name></name><argument_list>()</argument_list></call> % 8) != 0) &amp;&amp; (((<call><name><name>bigInt</name>.<name>bitLength</name></name><argument_list>()</argument_list></call> / 8) + 1) == (<name>bitlen</name> / 8))</expr>)</condition><then> <block>{
            <return>return <expr><name>bigBytes</name></expr>;</return>
        }</block></then></if>
        <comment type="line">// set up params for copying everything but sign bit</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>startSrc</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr><name><name>bigBytes</name>.<name>length</name></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// if bigInt is exactly byte-aligned, just skip signbit in copy</comment>
        <if>if <condition>(<expr>(<call><name><name>bigInt</name>.<name>bitLength</name></name><argument_list>()</argument_list></call> % 8) == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>startSrc</name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name>--</expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>startDst</name> =<init> <expr><name>bitlen</name> / 8 - <name>len</name></expr></init></decl>;</decl_stmt> <comment type="line">// to pad w/ nulls as per spec</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>resizedBytes</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name>bitlen</name> / 8</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name>bigBytes</name></expr></argument>, <argument><expr><name>startSrc</name></expr></argument>, <argument><expr><name>resizedBytes</name></expr></argument>, <argument><expr><name>startDst</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>resizedBytes</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns whether or not the &lt;code&gt;octet&lt;/code&gt; is in the Base64 alphabet.
     *
     * @param octet
     *            The value to test
     * @return {@code true} if the value is defined in the the Base64 alphabet {@code false} otherwise.
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>protected</specifier> <name>boolean</name></type> <name>isInAlphabet</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>byte</name></type> <name>octet</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name>octet</name> &gt;= 0 &amp;&amp; <name>octet</name> &lt; <name><name>decodeTable</name>.<name>length</name></name> &amp;&amp; <name><name>decodeTable</name><index>[<expr><name>octet</name></expr>]</index></name> != -1</expr>;</return>
    }</block></function>

}</block></class>
</unit>
