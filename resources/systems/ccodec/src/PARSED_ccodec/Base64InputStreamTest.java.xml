<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\David\IdeaProjects\arem\resources\systems\ccodec\src\test\java\org\apache\commons\codec\binary\Base64InputStreamTest.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>binary</name></name>;</package>

<import>import static <name><name>org</name>.<name>junit</name>.<name>Assert</name>.<name>assertArrayEquals</name></name>;</import>
<import>import static <name><name>org</name>.<name>junit</name>.<name>Assert</name>.<name>assertEquals</name></name>;</import>
<import>import static <name><name>org</name>.<name>junit</name>.<name>Assert</name>.<name>assertFalse</name></name>;</import>
<import>import static <name><name>org</name>.<name>junit</name>.<name>Assert</name>.<name>assertNotNull</name></name>;</import>
<import>import static <name><name>org</name>.<name>junit</name>.<name>Assert</name>.<name>assertTrue</name></name>;</import>
<import>import static <name><name>org</name>.<name>junit</name>.<name>Assert</name>.<name>fail</name></name>;</import>

<import>import <name><name>java</name>.<name>io</name>.<name>BufferedReader</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>ByteArrayInputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>ByteArrayOutputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>InputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>InputStreamReader</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Arrays</name></name>;</import>

<import>import <name><name>org</name>.<name>junit</name>.<name>Test</name></name>;</import>

<comment type="javadoc">/**
 * @version $Id $
 * @since 1.4
 */</comment>
<class><specifier>public</specifier> class <name>Base64InputStreamTest</name> <block>{

    <comment type="javadoc">/**
     * Decodes to {0, 0, 0, 255, 255, 255}
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ENCODED_B64</name> =<init> <expr>"AAAA////"</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>CRLF</name> =<init> <expr><block>{ <expr>(<name>byte</name>) '\r'</expr>, <expr>(<name>byte</name>) '\n'</expr> }</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <specifier>static</specifier> <name>byte</name><index>[]</index></type> <name>LF</name> =<init> <expr><block>{ <expr>(<name>byte</name>) '\n'</expr> }</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>STRING_FIXTURE</name> =<init> <expr>"Hello World"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Tests the problem reported in CODEC-130. Missing / wrong implementation of skip.
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testCodec130</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>ByteArrayOutputStream</name></type> <name>bos</name> =<init> <expr>new <call><name>ByteArrayOutputStream</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64OutputStream</name></type> <name>base64os</name> =<init> <expr>new <call><name>Base64OutputStream</name><argument_list>(<argument><expr><name>bos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>base64os</name>.<name>write</name></name><argument_list>(<argument><expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>STRING_FIXTURE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>base64os</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>ByteArrayInputStream</name></type> <name>bis</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><call><name><name>bos</name>.<name>toByteArray</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>ins</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>bis</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// we skip the first character read from the reader</comment>
        <expr_stmt><expr><call><name><name>ins</name>.<name>skip</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>decodedBytes</name> =<init> <expr><call><name><name>Base64TestData</name>.<name>streamToBytes</name></name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr>new <name><name>byte</name><index>[<expr>64</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name> =<init> <expr><call><name><name>StringUtils</name>.<name>newStringUtf8</name></name><argument_list>(<argument><expr><name>decodedBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><call><name><name>STRING_FIXTURE</name>.<name>substring</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testCodec105</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>in</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr>new <call><name>Codec105ErrorInputStream</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 5</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block> <finally>finally <block>{
            <expr_stmt><expr><call><name><name>in</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="javadoc">/**
     * Test for the CODEC-101 bug: InputStream.read(byte[]) should never return 0 because Java's builtin InputStreamReader hates that.
     *
     * @throws Exception
     *             for some failure scenarios.
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testCodec101</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>codec101</name> =<init> <expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name><name>Base64TestData</name>.<name>CODEC_101_MULTIPLE_OF_3</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ByteArrayInputStream</name></type> <name>bais</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>codec101</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>in</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>bais</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>result</name> =<init> <expr>new <name><name>byte</name><index>[<expr>8192</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>c</name> =<init> <expr><call><name><name>in</name>.<name>read</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr>"Codec101: First read successful [c=" + <name>c</name> + "]"</expr></argument>, <argument><expr><name>c</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>c</name> = <call><name><name>in</name>.<name>read</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr>"Codec101: Second read should report end-of-stream [c=" + <name>c</name> + "]"</expr></argument>, <argument><expr><name>c</name> &lt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>in</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Another test for the CODEC-101 bug: In commons-codec-1.4 this test shows InputStreamReader explicitly hating an
     * InputStream.read(byte[]) return of 0:
     *
     * java.io.IOException: Underlying input stream returned zero bytes at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268) at
     * sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158) at
     * java.io.InputStreamReader.read(InputStreamReader.java:167) at java.io.BufferedReader.fill(BufferedReader.java:136) at
     * java.io.BufferedReader.readLine(BufferedReader.java:299) at java.io.BufferedReader.readLine(BufferedReader.java:362) at
     * org.apache.commons.codec.binary.Base64InputStreamTest.testInputStreamReader(Base64InputStreamTest.java:75)
     *
     * But in commons-codec-1.5 it's fixed. :-)
     *
     * @throws Exception
     *             for some failure scenarios.
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testInputStreamReader</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>codec101</name> =<init> <expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name><name>Base64TestData</name>.<name>CODEC_101_MULTIPLE_OF_3</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ByteArrayInputStream</name></type> <name>bais</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>codec101</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>in</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>bais</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>InputStreamReader</name></type> <name>isr</name> =<init> <expr>new <call><name>InputStreamReader</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BufferedReader</name></type> <name>br</name> =<init> <expr>new <call><name>BufferedReader</name><argument_list>(<argument><expr><name>isr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>line</name> =<init> <expr><call><name><name>br</name>.<name>readLine</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertNotNull</name><argument_list>(<argument><expr>"Codec101:  InputStreamReader works!"</expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>br</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Test the Base64InputStream implementation against the special NPE inducing input identified in the CODEC-98 bug.
     *
     * @throws Exception
     *             for some failure scenarios.
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testCodec98NPE</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>codec98</name> =<init> <expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name><name>Base64TestData</name>.<name>CODEC_98_NPE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ByteArrayInputStream</name></type> <name>data</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>codec98</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>stream</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// This line causes an NPE in commons-codec-1.4.jar:</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>decodedBytes</name> =<init> <expr><call><name><name>Base64TestData</name>.<name>streamToBytes</name></name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>new <name><name>byte</name><index>[<expr>1024</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>decoded</name> =<init> <expr><call><name><name>StringUtils</name>.<name>newStringUtf8</name></name><argument_list>(<argument><expr><name>decodedBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"codec-98 NPE Base64InputStream"</expr></argument>, <argument><expr><name><name>Base64TestData</name>.<name>CODEC_98_NPE_DECODED</name></name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests skipping past the end of a stream.
     *
     * @throws Throwable
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testAvailable</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Throwable</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>InputStream</name></type> <name>ins</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><call><name><name>StringUtils</name>.<name>getBytesIso8859_1</name></name><argument_list>(<argument><expr><name>ENCODED_B64</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>b64stream</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>available</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>6</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>skip</name></name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// End of stream reached</comment>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>available</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>available</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>b64stream</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests the Base64InputStream implementation against empty input.
     *
     * @throws Exception
     *             for some failure scenarios.
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testBase64EmptyInputStreamMimeChuckSize</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>testBase64EmptyInputStream</name><argument_list>(<argument><expr><name><name>BaseNCodec</name>.<name>MIME_CHUNK_SIZE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests the Base64InputStream implementation against empty input.
     *
     * @throws Exception
     *             for some failure scenarios.
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testBase64EmptyInputStreamPemChuckSize</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <expr_stmt><expr><call><name>testBase64EmptyInputStream</name><argument_list>(<argument><expr><name><name>BaseNCodec</name>.<name>PEM_CHUNK_SIZE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>testBase64EmptyInputStream</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>chuckSize</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>emptyEncoded</name> =<init> <expr>new <name><name>byte</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>emptyDecoded</name> =<init> <expr>new <name><name>byte</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testByteByByte</name><argument_list>(<argument><expr><name>emptyEncoded</name></expr></argument>, <argument><expr><name>emptyDecoded</name></expr></argument>, <argument><expr><name>chuckSize</name></expr></argument>, <argument><expr><name>CRLF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testByChunk</name><argument_list>(<argument><expr><name>emptyEncoded</name></expr></argument>, <argument><expr><name>emptyDecoded</name></expr></argument>, <argument><expr><name>chuckSize</name></expr></argument>, <argument><expr><name>CRLF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests the Base64InputStream implementation.
     *
     * @throws Exception
     *             for some failure scenarios.
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testBase64InputStreamByChunk</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <comment type="line">// Hello World test.</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>encoded</name> =<init> <expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr>"SGVsbG8gV29ybGQ=\r\n"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>decoded</name> =<init> <expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>STRING_FIXTURE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testByChunk</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr><name><name>BaseNCodec</name>.<name>MIME_CHUNK_SIZE</name></name></expr></argument>, <argument><expr><name>CRLF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Single Byte test.</comment>
        <expr_stmt><expr><name>encoded</name> = <call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr>"AA==\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = new <name><name>byte</name><index>[]</index></name> <block>{ <expr>(<name>byte</name>) 0</expr> }</block></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testByChunk</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr><name><name>BaseNCodec</name>.<name>MIME_CHUNK_SIZE</name></name></expr></argument>, <argument><expr><name>CRLF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// OpenSSL interop test.</comment>
        <expr_stmt><expr><name>encoded</name> = <call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name><name>Base64TestData</name>.<name>ENCODED_64_CHARS_PER_LINE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <name><name>Base64TestData</name>.<name>DECODED</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testByChunk</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr><name><name>BaseNCodec</name>.<name>PEM_CHUNK_SIZE</name></name></expr></argument>, <argument><expr><name>LF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Single Line test.</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>singleLine</name> =<init> <expr><call><name><name>Base64TestData</name>.<name>ENCODED_64_CHARS_PER_LINE</name>.<name>replaceAll</name></name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>encoded</name> = <call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>singleLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <name><name>Base64TestData</name>.<name>DECODED</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testByChunk</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>LF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// test random data of sizes 0 thru 150</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= 150</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index><index>[]</index></type> <name>randomData</name> =<init> <expr><call><name><name>Base64TestData</name>.<name>randomData</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>encoded</name> = <name><name>randomData</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>decoded</name> = <name><name>randomData</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testByChunk</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>LF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Tests the Base64InputStream implementation.
     *
     * @throws Exception
     *             for some failure scenarios.
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testBase64InputStreamByteByByte</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <comment type="line">// Hello World test.</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>encoded</name> =<init> <expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr>"SGVsbG8gV29ybGQ=\r\n"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>decoded</name> =<init> <expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>STRING_FIXTURE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testByteByByte</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr><name><name>BaseNCodec</name>.<name>MIME_CHUNK_SIZE</name></name></expr></argument>, <argument><expr><name>CRLF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Single Byte test.</comment>
        <expr_stmt><expr><name>encoded</name> = <call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr>"AA==\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = new <name><name>byte</name><index>[]</index></name> <block>{ <expr>(<name>byte</name>) 0</expr> }</block></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testByteByByte</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr><name><name>BaseNCodec</name>.<name>MIME_CHUNK_SIZE</name></name></expr></argument>, <argument><expr><name>CRLF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// OpenSSL interop test.</comment>
        <expr_stmt><expr><name>encoded</name> = <call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name><name>Base64TestData</name>.<name>ENCODED_64_CHARS_PER_LINE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <name><name>Base64TestData</name>.<name>DECODED</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testByteByByte</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr><name><name>BaseNCodec</name>.<name>PEM_CHUNK_SIZE</name></name></expr></argument>, <argument><expr><name>LF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Single Line test.</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>singleLine</name> =<init> <expr><call><name><name>Base64TestData</name>.<name>ENCODED_64_CHARS_PER_LINE</name>.<name>replaceAll</name></name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>encoded</name> = <call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>singleLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <name><name>Base64TestData</name>.<name>DECODED</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testByteByByte</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>LF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// test random data of sizes 0 thru 150</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= 150</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index><index>[]</index></type> <name>randomData</name> =<init> <expr><call><name><name>Base64TestData</name>.<name>randomData</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>encoded</name> = <name><name>randomData</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>decoded</name> = <name><name>randomData</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testByteByByte</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>LF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="javadoc">/**
     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--&gt; decoded 2. decoded ---[ENCODE]--&gt; encoded 3. decoded
     * ---[WRAP-WRAP-WRAP-etc...] --&gt; decoded
     * &lt;p/&gt;
     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64InputStream wraps itself in encode and decode mode over and over
     * again.
     *
     * @param encoded
     *            base64 encoded data
     * @param decoded
     *            the data from above, but decoded
     * @param chunkSize
     *            chunk size (line-length) of the base64 encoded data.
     * @param separator
     *            Line separator in the base64 encoded data.
     * @throws Exception
     *             Usually signifies a bug in the Base64 commons-codec implementation.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>testByChunk</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>encoded</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>decoded</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>chunkSize</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>separator</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{

        <comment type="line">// Start with encode.</comment>
        <decl_stmt><decl><type><name>InputStream</name></type> <name>in</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>in</name> = new <call><name>Base64InputStream</name><argument_list>(<argument><expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr><name>chunkSize</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>output</name> =<init> <expr><call><name><name>Base64TestData</name>.<name>streamToBytes</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"Still EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr>"Streaming base64 encode"</expr></argument>, <argument><expr><call><name><name>Arrays</name>.<name>equals</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>in</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Now let's try decode.</comment>
        <expr_stmt><expr><name>in</name> = new <call><name>Base64InputStream</name><argument_list>(<argument><expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>output</name> = <call><name><name>Base64TestData</name>.<name>streamToBytes</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"Still EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr>"Streaming base64 decode"</expr></argument>, <argument><expr><call><name><name>Arrays</name>.<name>equals</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// I always wanted to do this! (wrap encoder with decoder etc etc).</comment>
        <expr_stmt><expr><name>in</name> = new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 10</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>in</name> = new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr><name>chunkSize</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>in</name> = new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>output</name> = <call><name><name>Base64TestData</name>.<name>streamToBytes</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"Still EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr>"Streaming base64 wrap-wrap-wrap!"</expr></argument>, <argument><expr><call><name><name>Arrays</name>.<name>equals</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>in</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--&gt; decoded 2. decoded ---[ENCODE]--&gt; encoded 3. decoded
     * ---[WRAP-WRAP-WRAP-etc...] --&gt; decoded
     * &lt;p/&gt;
     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64InputStream wraps itself in encode and decode mode over and over
     * again.
     *
     * @param encoded
     *            base64 encoded data
     * @param decoded
     *            the data from above, but decoded
     * @param chunkSize
     *            chunk size (line-length) of the base64 encoded data.
     * @param separator
     *            Line separator in the base64 encoded data.
     * @throws Exception
     *             Usually signifies a bug in the Base64 commons-codec implementation.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>testByteByByte</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>encoded</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>decoded</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>chunkSize</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>separator</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{

        <comment type="line">// Start with encode.</comment>
        <decl_stmt><decl><type><name>InputStream</name></type> <name>in</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>in</name> = new <call><name>Base64InputStream</name><argument_list>(<argument><expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr><name>chunkSize</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>output</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name><name>encoded</name>.<name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>output</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>byte</name>) <call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"Still EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr>"Streaming base64 encode"</expr></argument>, <argument><expr><call><name><name>Arrays</name>.<name>equals</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>in</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Now let's try decode.</comment>
        <expr_stmt><expr><name>in</name> = new <call><name>Base64InputStream</name><argument_list>(<argument><expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>output</name> = new <name><name>byte</name><index>[<expr><name><name>decoded</name>.<name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>output</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>byte</name>) <call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"Still EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr>"Streaming base64 decode"</expr></argument>, <argument><expr><call><name><name>Arrays</name>.<name>equals</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>in</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// I always wanted to do this! (wrap encoder with decoder etc etc).</comment>
        <expr_stmt><expr><name>in</name> = new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 10</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>in</name> = new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr><name>chunkSize</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>in</name> = new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>output</name> = new <name><name>byte</name><index>[<expr><name><name>decoded</name>.<name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>output</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>output</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>byte</name>) <call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"Still EOF"</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name><name>in</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr>"Streaming base64 wrap-wrap-wrap!"</expr></argument>, <argument><expr><call><name><name>Arrays</name>.<name>equals</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>in</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests markSupported.
     *
     * @throws Exception
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testMarkSupported</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>decoded</name> =<init> <expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>STRING_FIXTURE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ByteArrayInputStream</name></type> <name>bin</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>in</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>new <name><name>byte</name><index>[]</index></name> <block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// Always returns false for now.</comment>
        <expr_stmt><expr><call><name>assertFalse</name><argument_list>(<argument><expr>"Base64InputStream.markSupported() is false"</expr></argument>, <argument><expr><call><name><name>in</name>.<name>markSupported</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>in</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests read returning 0
     *
     * @throws Exception
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testRead0</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>decoded</name> =<init> <expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>STRING_FIXTURE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buf</name> =<init> <expr>new <name><name>byte</name><index>[<expr>1024</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bytesRead</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ByteArrayInputStream</name></type> <name>bin</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>in</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>new <name><name>byte</name><index>[]</index></name> <block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>bytesRead</name> = <call><name><name>in</name>.<name>read</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"Base64InputStream.read(buf, 0, 0) returns 0"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>in</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests read with null.
     *
     * @throws Exception
     *             for some failure scenarios.
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testReadNull</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>decoded</name> =<init> <expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>STRING_FIXTURE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ByteArrayInputStream</name></type> <name>bin</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>in</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>new <name><name>byte</name><index>[]</index></name> <block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try <block>{
            <expr_stmt><expr><call><name><name>in</name>.<name>read</name></name><argument_list>(<argument><expr><name>null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr>"Base64InputStream.read(null, 0, 0) to throw a NullPointerException"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><specifier>final</specifier> <name>NullPointerException</name></type> <name>e</name></decl></param>) <block>{
            <comment type="line">// Expected</comment>
        }</block></catch></try>
        <expr_stmt><expr><call><name><name>in</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests read throwing IndexOutOfBoundsException
     *
     * @throws Exception
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testReadOutOfBounds</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>decoded</name> =<init> <expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>STRING_FIXTURE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buf</name> =<init> <expr>new <name><name>byte</name><index>[<expr>1024</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ByteArrayInputStream</name></type> <name>bin</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>in</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>new <name><name>byte</name><index>[]</index></name> <block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <try>try <block>{
            <expr_stmt><expr><call><name><name>in</name>.<name>read</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr>"Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><specifier>final</specifier> <name>IndexOutOfBoundsException</name></type> <name>e</name></decl></param>) <block>{
            <comment type="line">// Expected</comment>
        }</block></catch></try>

        <try>try <block>{
            <expr_stmt><expr><call><name><name>in</name>.<name>read</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr>"Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><specifier>final</specifier> <name>IndexOutOfBoundsException</name></type> <name>e</name></decl></param>) <block>{
            <comment type="line">// Expected</comment>
        }</block></catch></try>

        <try>try <block>{
            <expr_stmt><expr><call><name><name>in</name>.<name>read</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name>.<name>length</name></name> + 1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr>"Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><specifier>final</specifier> <name>IndexOutOfBoundsException</name></type> <name>e</name></decl></param>) <block>{
            <comment type="line">// Expected</comment>
        }</block></catch></try>

        <try>try <block>{
            <expr_stmt><expr><call><name><name>in</name>.<name>read</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name>.<name>length</name></name> - 1</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr>"Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><specifier>final</specifier> <name>IndexOutOfBoundsException</name></type> <name>e</name></decl></param>) <block>{
            <comment type="line">// Expected</comment>
        }</block></catch></try>
        <expr_stmt><expr><call><name><name>in</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests skipping number of characters larger than the internal buffer.
     *
     * @throws Throwable
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testSkipBig</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Throwable</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>InputStream</name></type> <name>ins</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><call><name><name>StringUtils</name>.<name>getBytesIso8859_1</name></name><argument_list>(<argument><expr><name>ENCODED_B64</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>b64stream</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>6</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>skip</name></name><argument_list>(<argument><expr><name><name>Integer</name>.<name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// End of stream reached</comment>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>b64stream</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests skipping as a noop
     *
     * @throws Throwable
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testSkipNone</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Throwable</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>InputStream</name></type> <name>ins</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><call><name><name>StringUtils</name>.<name>getBytesIso8859_1</name></name><argument_list>(<argument><expr><name>ENCODED_B64</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>b64stream</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>actualBytes</name> =<init> <expr>new <name><name>byte</name><index>[<expr>6</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>skip</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>b64stream</name>.<name>read</name></name><argument_list>(<argument><expr><name>actualBytes</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>actualBytes</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>actualBytes</name></expr></argument>, <argument><expr>new <name><name>byte</name><index>[]</index></name> <block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>(<name>byte</name>) 255</expr>, <expr>(<name>byte</name>) 255</expr>, <expr>(<name>byte</name>) 255</expr> }</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// End of stream reached</comment>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>b64stream</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests skipping past the end of a stream.
     *
     * @throws Throwable
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testSkipPastEnd</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Throwable</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>InputStream</name></type> <name>ins</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><call><name><name>StringUtils</name>.<name>getBytesIso8859_1</name></name><argument_list>(<argument><expr><name>ENCODED_B64</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>b64stream</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// due to CODEC-130, skip now skips correctly decoded characters rather than encoded</comment>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>6</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>skip</name></name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// End of stream reached</comment>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>b64stream</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests skipping to the end of a stream.
     *
     * @throws Throwable
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testSkipToEnd</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Throwable</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>InputStream</name></type> <name>ins</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><call><name><name>StringUtils</name>.<name>getBytesIso8859_1</name></name><argument_list>(<argument><expr><name>ENCODED_B64</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>b64stream</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// due to CODEC-130, skip now skips correctly decoded characters rather than encoded</comment>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>6</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>skip</name></name><argument_list>(<argument><expr>6</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// End of stream reached</comment>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><call><name><name>b64stream</name>.<name>read</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>b64stream</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests if negative arguments to skip are handled correctly.
     *
     * @throws Throwable
     */</comment>
    <function><type><annotation>@<name>Test</name><argument_list>(expected=IllegalArgumentException.class)</argument_list></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testSkipWrongArgument</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Throwable</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>InputStream</name></type> <name>ins</name> =<init> <expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><call><name><name>StringUtils</name>.<name>getBytesIso8859_1</name></name><argument_list>(<argument><expr><name>ENCODED_B64</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Base64InputStream</name></type> <name>b64stream</name> =<init> <expr>new <call><name>Base64InputStream</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>b64stream</name>.<name>skip</name></name><argument_list>(<argument><expr>-10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>b64stream</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>
}</block></class>
</unit>
