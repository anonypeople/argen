<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\David\IdeaProjects\arem\resources\systems\ccodec\src\main\java\org\apache\commons\codec\binary\BaseNCodec.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>binary</name></name>;</package>

<import>import <name><name>java</name>.<name>util</name>.<name>Arrays</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>BinaryDecoder</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>BinaryEncoder</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>DecoderException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>EncoderException</name></name>;</import>

<comment type="javadoc">/**
 * Abstract superclass for Base-N encoders and decoders.
 *
 * &lt;p&gt;
 * This class is thread-safe.
 * &lt;/p&gt;
 *
 * @version $Id: BaseNCodec.java 1465182 2013-04-06 04:03:12Z ggregory $
 */</comment>
<class><specifier>public</specifier> <specifier>abstract</specifier> class <name>BaseNCodec</name> <super><implements>implements <name>BinaryEncoder</name>, <name>BinaryDecoder</name></implements></super> <block>{

    <comment type="javadoc">/**
     * Holds thread context so classes can be thread-safe.
     *
     * This class is not itself thread-safe; each thread must allocate its own copy.
     *
     * @since 1.7
     */</comment>
    <class><specifier>static</specifier> class <name>Context</name> <block>{

        <comment type="javadoc">/**
         * Place holder for the bytes we're dealing with for our based logic.
         * Bitwise operations store and extract the encoding or decoding from this variable.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>ibitWorkArea</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Place holder for the bytes we're dealing with for our based logic.
         * Bitwise operations store and extract the encoding or decoding from this variable.
         */</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>lbitWorkArea</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Buffer for streaming.
         */</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>buffer</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Position where next character should be written in the buffer.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Position where next character should be read from the buffer.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>readPos</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,
         * and must be thrown away.
         */</comment>
        <decl_stmt><decl><type><name>boolean</name></type> <name>eof</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Variable tracks how many characters have been written to the current line. Only used when encoding. We use
         * it to make sure each encoded line never goes beyond lineLength (if lineLength &gt; 0).
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>currentLinePos</name></decl>;</decl_stmt>

        <comment type="javadoc">/**
         * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding. This
         * variable helps track that.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>modulus</name></decl>;</decl_stmt>

        <constructor><name>Context</name><parameter_list>()</parameter_list> <block>{
        }</block></constructor>

        <comment type="javadoc">/**
         * Returns a String useful for debugging (especially within a debugger.)
         *
         * @return a String useful for debugging.
         */</comment>
        <function><type><annotation>@<name>SuppressWarnings</name><argument_list>("boxing")</argument_list></annotation> <comment type="line">// OK to ignore boxing here</comment>
        <annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, " +
                    "modulus=%s, pos=%s, readPos=%s]"</expr></argument>, <argument><expr><call><name><name>this</name>.<name>getClass</name></name><argument_list>()</argument_list></call>.<call><name>getSimpleName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Arrays</name>.<name>toString</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>currentLinePos</name></expr></argument>, <argument><expr><name>eof</name></expr></argument>, <argument><expr><name>ibitWorkArea</name></expr></argument>, <argument><expr><name>lbitWorkArea</name></expr></argument>, <argument><expr><name>modulus</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>readPos</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * EOF
     *
     * @since 1.7
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>EOF</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     *  MIME chunk size per RFC 2045 section 6.8.
     *
     * &lt;p&gt;
     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any
     * equal signs.
     * &lt;/p&gt;
     *
     * @see &lt;a href="http://www.ietf.org/rfc/rfc2045.txt"&gt;RFC 2045 section 6.8&lt;/a&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MIME_CHUNK_SIZE</name> =<init> <expr>76</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * PEM chunk size per RFC 1421 section 4.3.2.4.
     *
     * &lt;p&gt;
     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any
     * equal signs.
     * &lt;/p&gt;
     *
     * @see &lt;a href="http://tools.ietf.org/html/rfc1421"&gt;RFC 1421 section 4.3.2.4&lt;/a&gt;
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>PEM_CHUNK_SIZE</name> =<init> <expr>64</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEFAULT_BUFFER_RESIZE_FACTOR</name> =<init> <expr>2</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Defines the default buffer size - currently {@value}
     * - must be large enough for at least one encoded block+separator
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEFAULT_BUFFER_SIZE</name> =<init> <expr>8192</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** Mask used to extract 8 bits, used in decoding bytes */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MASK_8BITS</name> =<init> <expr>0xff</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Byte used to pad output.
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>byte</name></type> <name>PAD_DEFAULT</name> =<init> <expr>'='</expr></init></decl>;</decl_stmt> <comment type="line">// Allow static access to default</comment>

    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>byte</name></type> <name>PAD</name> =<init> <expr><name>PAD_DEFAULT</name></expr></init></decl>;</decl_stmt> <comment type="line">// instance variable just in case it needs to vary later</comment>

    <comment type="javadoc">/** Number of bytes in each full block of unencoded data, e.g. 4 for Base64 and 5 for Base32 */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>unencodedBlockSize</name></decl>;</decl_stmt>

    <comment type="javadoc">/** Number of bytes in each full block of encoded data, e.g. 3 for Base64 and 8 for Base32 */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>encodedBlockSize</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Chunksize for encoding. Not used when decoding.
     * A value of zero or less implies no chunking of the encoded data.
     * Rounded down to nearest multiple of encodedBlockSize.
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>int</name></type> <name>lineLength</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Size of chunk separator. Not used unless {@link #lineLength} &gt; 0.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>chunkSeparatorLength</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Note &lt;code&gt;lineLength&lt;/code&gt; is rounded down to the nearest multiple of {@link #encodedBlockSize}
     * If &lt;code&gt;chunkSeparatorLength&lt;/code&gt; is zero, then chunking is disabled.
     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)
     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)
     * @param lineLength if &amp;gt; 0, use chunking with a length &lt;code&gt;lineLength&lt;/code&gt;
     * @param chunkSeparatorLength the chunk separator length, if relevant
     */</comment>
    <constructor><specifier>protected</specifier> <name>BaseNCodec</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>unencodedBlockSize</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>encodedBlockSize</name></decl></param>,
                         <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>lineLength</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>chunkSeparatorLength</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>unencodedBlockSize</name></name> = <name>unencodedBlockSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>encodedBlockSize</name></name> = <name>encodedBlockSize</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>useChunking</name> =<init> <expr><name>lineLength</name> &gt; 0 &amp;&amp; <name>chunkSeparatorLength</name> &gt; 0</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>lineLength</name></name> = <name>useChunking</name> ? (<name>lineLength</name> / <name>encodedBlockSize</name>) * <name>encodedBlockSize</name> : 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>chunkSeparatorLength</name></name> = <name>chunkSeparatorLength</name></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Returns true if this object has buffered data for reading.
     *
     * @param context the context to be used
     * @return true if there is data still available for reading.
     */</comment>
    <function><type><name>boolean</name></type> <name>hasData</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Context</name></type> <name>context</name></decl></param>)</parameter_list> <block>{  <comment type="line">// package protected for access from I/O streams</comment>
        <return>return <expr><name><name>context</name>.<name>buffer</name></name> != <name>null</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the amount of buffered data available for reading.
     *
     * @param context the context to be used
     * @return The amount of buffered data available for reading.
     */</comment>
    <function><type><name>int</name></type> <name>available</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Context</name></type> <name>context</name></decl></param>)</parameter_list> <block>{  <comment type="line">// package protected for access from I/O streams</comment>
        <return>return <expr><name><name>context</name>.<name>buffer</name></name> != <name>null</name> ? <name><name>context</name>.<name>pos</name></name> - <name><name>context</name>.<name>readPos</name></name> : 0</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Get the default buffer size. Can be overridden.
     *
     * @return {@link #DEFAULT_BUFFER_SIZE}
     */</comment>
    <function><type><specifier>protected</specifier> <name>int</name></type> <name>getDefaultBufferSize</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>DEFAULT_BUFFER_SIZE</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.
     * @param context the context to be used
     */</comment>
    <function><type><specifier>private</specifier> <name>byte</name><index>[]</index></type> <name>resizeBuffer</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Context</name></type> <name>context</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>context</name>.<name>buffer</name></name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>context</name>.<name>buffer</name></name> = new <name><name>byte</name><index>[<expr><call><name>getDefaultBufferSize</name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name>.<name>pos</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name>.<name>readPos</name></name> = 0</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>b</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name><name>context</name>.<name>buffer</name>.<name>length</name></name> * <name>DEFAULT_BUFFER_RESIZE_FACTOR</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name><name>context</name>.<name>buffer</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>context</name>.<name>buffer</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name>.<name>buffer</name></name> = <name>b</name></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name><name>context</name>.<name>buffer</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Ensure that the buffer has room for &lt;code&gt;size&lt;/code&gt; bytes
     *
     * @param size minimum spare space required
     * @param context the context to be used
     */</comment>
    <function><type><specifier>protected</specifier> <name>byte</name><index>[]</index></type> <name>ensureBufferSize</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>size</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>Context</name></type> <name>context</name></decl></param>)</parameter_list><block>{
        <if>if <condition>(<expr>(<name><name>context</name>.<name>buffer</name></name> == <name>null</name>) || (<name><name>context</name>.<name>buffer</name>.<name>length</name></name> &lt; <name><name>context</name>.<name>pos</name></name> + <name>size</name>)</expr>)</condition><then><block>{
            <return>return <expr><call><name>resizeBuffer</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><name><name>context</name>.<name>buffer</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail
     * bytes. Returns how many bytes were actually extracted.
     * &lt;p&gt;
     * Package protected for access from I/O streams.
     *
     * @param b
     *            byte[] array to extract the buffered data into.
     * @param bPos
     *            position in byte[] array to start extraction at.
     * @param bAvail
     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).
     * @param context
     *            the context to be used
     * @return The number of bytes successfully extracted into the provided byte[] array.
     */</comment>
    <function><type><name>int</name></type> <name>readResults</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>b</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>bPos</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>bAvail</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>Context</name></type> <name>context</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>context</name>.<name>buffer</name></name> != <name>null</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>len</name> =<init> <expr><call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><call><name>available</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bAvail</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>arraycopy</name></name><argument_list>(<argument><expr><name><name>context</name>.<name>buffer</name></name></expr></argument>, <argument><expr><name><name>context</name>.<name>readPos</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>bPos</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name>.<name>readPos</name></name> += <name>len</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>context</name>.<name>readPos</name></name> &gt;= <name><name>context</name>.<name>pos</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>context</name>.<name>buffer</name></name> = <name>null</name></expr>;</expr_stmt> <comment type="line">// so hasData() will return false, and this method can return -1</comment>
            }</block></then></if>
            <return>return <expr><name>len</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name><name>context</name>.<name>eof</name></name> ? <name>EOF</name> : 0</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Checks if a byte value is whitespace or not.
     * Whitespace is taken to mean: space, tab, CR, LF
     * @param byteToCheck
     *            the byte to check
     * @return true if byte is whitespace, false otherwise
     */</comment>
    <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isWhiteSpace</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>byte</name></type> <name>byteToCheck</name></decl></param>)</parameter_list> <block>{
        <switch>switch <condition>(<expr><name>byteToCheck</name></expr>)</condition> <block>{
            <case>case <expr>' '</expr> :
            </case><case>case <expr>'\n'</expr> :
            </case><case>case <expr>'\r'</expr> :
            </case><case>case <expr>'\t'</expr> :
                <return>return <expr>true</expr>;</return>
            </case><default>default :
                <return>return <expr>false</expr>;</return>
        </default>}</block></switch>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of
     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
     *
     * @param obj
     *            Object to encode
     * @return An object (of type byte[]) containing the Base-N encoded data which corresponds to the byte[] supplied.
     * @throws EncoderException
     *             if the parameter supplied is not of type byte[]
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>Object</name></type> <name>encode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>EncoderException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr>!(<name>obj</name> <name>instanceof</name> <name><name>byte</name><index>[]</index></name>)</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>EncoderException</name><argument_list>(<argument><expr>"Parameter supplied to Base-N encode is not a byte[]"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name>encode</name><argument_list>(<argument><expr>(<name><name>byte</name><index>[]</index></name>) <name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.
     * Uses UTF8 encoding.
     *
     * @param pArray
     *            a byte array containing binary data
     * @return A String containing only Base-N character data
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>encodeToString</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>pArray</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>StringUtils</name>.<name>newStringUtf8</name></name><argument_list>(<argument><expr><call><name>encode</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.
     * Uses UTF8 encoding.
     *
     * @param pArray a byte array containing binary data
     * @return String containing only character data in the appropriate alphabet.
    */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>encodeAsString</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>pArray</name></decl></param>)</parameter_list><block>{
        <return>return <expr><call><name><name>StringUtils</name>.<name>newStringUtf8</name></name><argument_list>(<argument><expr><call><name>encode</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of
     * the Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.
     *
     * @param obj
     *            Object to decode
     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String
     *         supplied.
     * @throws DecoderException
     *             if the parameter supplied is not of type byte[]
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>Object</name></type> <name>decode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>DecoderException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr><name>obj</name> <name>instanceof</name> <name><name>byte</name><index>[]</index></name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>decode</name><argument_list>(<argument><expr>(<name><name>byte</name><index>[]</index></name>) <name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <if>if <condition>(<expr><name>obj</name> <name>instanceof</name> <name>String</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>decode</name><argument_list>(<argument><expr>(<name>String</name>) <name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <block>{
            <throw>throw <expr>new <call><name>DecoderException</name><argument_list>(<argument><expr>"Parameter supplied to Base-N decode is not a byte[] or a String"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></else></if></else></if>
    }</block></function>

    <comment type="javadoc">/**
     * Decodes a String containing characters in the Base-N alphabet.
     *
     * @param pArray
     *            A String containing Base-N character data
     * @return a byte array containing binary data
     */</comment>
    <function><type><specifier>public</specifier> <name>byte</name><index>[]</index></type> <name>decode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>pArray</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>decode</name><argument_list>(<argument><expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Decodes a byte[] containing characters in the Base-N alphabet.
     *
     * @param pArray
     *            A byte array containing Base-N character data
     * @return a byte array containing binary data
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>byte</name><index>[]</index></type> <name>decode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>pArray</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>pArray</name> == <name>null</name> || <name><name>pArray</name>.<name>length</name></name> == 0</expr>)</condition><then> <block>{
            <return>return <expr><name>pArray</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Context</name></type> <name>context</name> =<init> <expr>new <call><name>Context</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>decode</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>pArray</name>.<name>length</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>decode</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>EOF</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Notify decoder of EOF.</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>result</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name><name>context</name>.<name>pos</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>readResults</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>result</name>.<name>length</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes a byte[] containing binary data, into a byte[] containing characters in the alphabet.
     *
     * @param pArray
     *            a byte array containing binary data
     * @return A byte array containing only the basen alphabetic character data
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>byte</name><index>[]</index></type> <name>encode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>pArray</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>pArray</name> == <name>null</name> || <name><name>pArray</name>.<name>length</name></name> == 0</expr>)</condition><then> <block>{
            <return>return <expr><name>pArray</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Context</name></type> <name>context</name> =<init> <expr>new <call><name>Context</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>encode</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>pArray</name>.<name>length</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>encode</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>EOF</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Notify encoder of EOF.</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>byte</name><index>[]</index></type> <name>buf</name> =<init> <expr>new <name><name>byte</name><index>[<expr><name><name>context</name>.<name>pos</name></name> - <name><name>context</name>.<name>readPos</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>readResults</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>buf</name>.<name>length</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>buf</name></expr>;</return>
    }</block></function>

    <comment type="line">// package protected for access from I/O streams</comment>
    <function_decl><type><specifier>abstract</specifier> <name>void</name></type> <name>encode</name><parameter_list>(<param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>pArray</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>length</name></decl></param>, <param><decl><type><name>Context</name></type> <name>context</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// package protected for access from I/O streams</comment>
    <function_decl><type><specifier>abstract</specifier> <name>void</name></type> <name>decode</name><parameter_list>(<param><decl><type><name><name>byte</name><index>[]</index></name></type> <name>pArray</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>length</name></decl></param>, <param><decl><type><name>Context</name></type> <name>context</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="javadoc">/**
     * Returns whether or not the &lt;code&gt;octet&lt;/code&gt; is in the current alphabet.
     * Does not allow whitespace or pad.
     *
     * @param value The value to test
     *
     * @return {@code true} if the value is defined in the current alphabet, {@code false} otherwise.
     */</comment>
    <function_decl><type><specifier>protected</specifier> <specifier>abstract</specifier> <name>boolean</name></type> <name>isInAlphabet</name><parameter_list>(<param><decl><type><name>byte</name></type> <name>value</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="javadoc">/**
     * Tests a given byte array to see if it contains only valid characters within the alphabet.
     * The method optionally treats whitespace and pad as valid.
     *
     * @param arrayOctet byte array to test
     * @param allowWSPad if {@code true}, then whitespace and PAD are also allowed
     *
     * @return {@code true} if all bytes are valid characters in the alphabet or if the byte array is empty;
     *         {@code false}, otherwise
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isInAlphabet</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>arrayOctet</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>allowWSPad</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>arrayOctet</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr>!<call><name>isInAlphabet</name><argument_list>(<argument><expr><name><name>arrayOctet</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp;
                    (!<name>allowWSPad</name> || (<name><name>arrayOctet</name><index>[<expr><name>i</name></expr>]</index></name> != <name>PAD</name>) &amp;&amp; !<call><name>isWhiteSpace</name><argument_list>(<argument><expr><name><name>arrayOctet</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Tests a given String to see if it contains only valid characters within the alphabet.
     * The method treats whitespace and PAD as valid.
     *
     * @param basen String to test
     * @return {@code true} if all characters in the String are valid characters in the alphabet or if
     *         the String is empty; {@code false}, otherwise
     * @see #isInAlphabet(byte[], boolean)
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isInAlphabet</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>basen</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>isInAlphabet</name><argument_list>(<argument><expr><call><name><name>StringUtils</name>.<name>getBytesUtf8</name></name><argument_list>(<argument><expr><name>basen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.
     *
     * Intended for use in checking line-ending arrays
     *
     * @param arrayOctet
     *            byte array to test
     * @return {@code true} if any byte is a valid character in the alphabet or PAD; {@code false} otherwise
     */</comment>
    <function><type><specifier>protected</specifier> <name>boolean</name></type> <name>containsAlphabetOrPad</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>arrayOctet</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>arrayOctet</name> == <name>null</name></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <for>for (<init><decl><type><specifier>final</specifier> <name>byte</name></type> <name>element</name> :<range> <expr><name>arrayOctet</name></expr></range></decl></init>) <block>{
            <if>if <condition>(<expr><name>PAD</name> == <name>element</name> || <call><name>isInAlphabet</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>true</expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Calculates the amount of space needed to encode the supplied array.
     *
     * @param pArray byte[] array which will later be encoded
     *
     * @return amount of space needed to encoded the supplied array.
     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>getEncodedLength</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>pArray</name></decl></param>)</parameter_list> <block>{
        <comment type="line">// Calculate non-chunked size - rounded up to allow for padding</comment>
        <comment type="line">// cast to long is needed to avoid possibility of overflow</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>len</name> =<init> <expr>((<name><name>pArray</name>.<name>length</name></name> + <name>unencodedBlockSize</name>-1)  / <name>unencodedBlockSize</name>) * (<name>long</name>) <name>encodedBlockSize</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>lineLength</name> &gt; 0</expr>)</condition><then> <block>{ <comment type="line">// We're using chunking</comment>
            <comment type="line">// Round up to nearest multiple</comment>
            <expr_stmt><expr><name>len</name> += ((<name>len</name> + <name>lineLength</name>-1) / <name>lineLength</name>) * <name>chunkSeparatorLength</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>len</name></expr>;</return>
    }</block></function>
}</block></class>
</unit>
