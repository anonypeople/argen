<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\David\IdeaProjects\arem\resources\systems\ccodec\src\test\java\org\apache\commons\codec\binary\BinaryCodecTest.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>binary</name></name>;</package>

<import>import static <name><name>org</name>.<name>junit</name>.<name>Assert</name>.<name>assertEquals</name></name>;</import>
<import>import static <name><name>org</name>.<name>junit</name>.<name>Assert</name>.<name>fail</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>Charsets</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>DecoderException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>EncoderException</name></name>;</import>
<import>import <name><name>org</name>.<name>junit</name>.<name>After</name></name>;</import>
<import>import <name><name>org</name>.<name>junit</name>.<name>Before</name></name>;</import>
<import>import <name><name>org</name>.<name>junit</name>.<name>Test</name></name>;</import>

<comment type="javadoc">/**
 * TestCase for BinaryCodec class.
 *
 * @version $Id: BinaryCodecTest.java 1429868 2013-01-07 16:08:05Z ggregory $
 */</comment>
<class><specifier>public</specifier> class <name>BinaryCodecTest</name> <block>{
    <comment type="javadoc">/** mask with bit zero based index 0 raised */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BIT_0</name> =<init> <expr>0x01</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** mask with bit zero based index 0 raised */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BIT_1</name> =<init> <expr>0x02</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** mask with bit zero based index 0 raised */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BIT_2</name> =<init> <expr>0x04</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** mask with bit zero based index 0 raised */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BIT_3</name> =<init> <expr>0x08</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** mask with bit zero based index 0 raised */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BIT_4</name> =<init> <expr>0x10</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** mask with bit zero based index 0 raised */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BIT_5</name> =<init> <expr>0x20</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** mask with bit zero based index 0 raised */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BIT_6</name> =<init> <expr>0x40</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** mask with bit zero based index 0 raised */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>BIT_7</name> =<init> <expr>0x80</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/** an instance of the binary codec */</comment>
    <decl_stmt><decl><type><name>BinaryCodec</name></type> <name>instance</name> =<init> <expr><name>null</name></expr></init></decl>;</decl_stmt>

    <function><type><annotation>@<name>Before</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>setUp</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>instance</name></name> = new <call><name>BinaryCodec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><annotation>@<name>After</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>tearDown</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>instance</name></name> = <name>null</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="line">//</comment>
    <comment type="line">// Test decode(Object)</comment>
    <comment type="line">//</comment>
    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="javadoc">/**
     * Tests for Object decode(Object)
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testDecodeObjectException</name><parameter_list>()</parameter_list> <block>{
        <try>try <block>{
            <expr_stmt><expr><call><name><name>this</name>.<name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>new <call><name>Object</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><specifier>final</specifier> <name>DecoderException</name></type> <name>e</name></decl></param>) <block>{
            <comment type="line">// all is well.</comment>
            <return>return;</return>
        }</block></catch></try>
        <expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr>"Expected DecoderException"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="javadoc">/**
     * Tests for Object decode(Object)
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testDecodeObject</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>bits</name></decl>;</decl_stmt>
        <comment type="line">// With a single raw binary</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"00000000"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"00000001"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"00000011"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"00000111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"00001111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"00011111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"00111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"01111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"11111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a two raw binaries</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"0000000011111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"0000000111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"0000001111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"0000011111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"0000111111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"0001111111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"0011111111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"0111111111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr>"1111111111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertDecodeObject</name><argument_list>(<argument><expr>new <name><name>byte</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="line">//</comment>
    <comment type="line">// Test decode(byte[])</comment>
    <comment type="line">//</comment>
    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="javadoc">/**
     * Utility used to assert the encoded and decoded values.
     *
     * @param bits
     *            the pre-encoded data
     * @param encodeMe
     *            data to encode and compare
     */</comment>
    <function><type><name>void</name></type> <name>assertDecodeObject</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index></name></type> <name>bits</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>encodeMe</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>DecoderException</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>decoded</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>decoded</name> = (<name><name>byte</name><index>[]</index></name>) <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr><name>encodeMe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>encodeMe</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>(<name><name>byte</name><index>[]</index></name>) <name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>decoded</name> = (<name><name>byte</name><index>[]</index></name>) <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <call><name><name>encodeMe</name>.<name>getBytes</name></name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>encodeMe</name> == <name>null</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>decoded</name> = (<name><name>byte</name><index>[]</index></name>) <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>decoded</name> = (<name><name>byte</name><index>[]</index></name>) <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr><call><name><name>encodeMe</name>.<name>toCharArray</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * Tests for byte[] decode(byte[])
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testDecodeByteArray</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// With a single raw binary</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>bits</name> =<init> <expr>new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>decoded</name> =<init> <expr><call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"00000000".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"00000001".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"00000011".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"00000111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"00001111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"00011111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"00111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"01111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"11111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a two raw binaries</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"0000000011111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"0000000111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"0000001111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"0000011111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"0000111111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"0001111111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"0011111111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"0111111111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>decode</name></name><argument_list>(<argument><expr>"1111111111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="line">//</comment>
    <comment type="line">// Test toByteArray(String)</comment>
    <comment type="line">//</comment>
    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="block">/*
     * Tests for byte[] toByteArray(String)
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testToByteArrayFromString</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// With a single raw binary</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>bits</name> =<init> <expr>new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>decoded</name> =<init> <expr><call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"00000000"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"00000001"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"00000011"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"00000111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"00001111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"00011111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"00111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"01111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"11111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a two raw binaries</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"0000000011111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"0000000111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"0000001111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"0000011111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"0000111111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"0001111111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"0011111111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"0111111111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>"1111111111111111"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>instance</name>.<name>toByteArray</name></name><argument_list>(<argument><expr>(<name>String</name>) <name>null</name></expr></argument>)</argument_list></call>.<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="line">//</comment>
    <comment type="line">// Test fromAscii(char[])</comment>
    <comment type="line">//</comment>
    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="block">/*
     * Tests for byte[] fromAscii(char[])
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testFromAsciiCharArray</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <name>null</name></expr></argument>)</argument_list></call>.<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>new <name><name>char</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>.<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a single raw binary</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>bits</name> =<init> <expr>new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>decoded</name> =<init> <expr><call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00000000".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00000001".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00000011".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00000111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00001111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00011111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"01111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"11111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a two raw binaries</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0000000011111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0000000111111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0000001111111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0000011111111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0000111111111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0001111111111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0011111111111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0111111111111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"1111111111111111".<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <name>null</name></expr></argument>)</argument_list></call>.<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="line">//</comment>
    <comment type="line">// Test fromAscii(byte[])</comment>
    <comment type="line">//</comment>
    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="block">/*
     * Tests for byte[] fromAscii(byte[])
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testFromAsciiByteArray</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>(<name><name>byte</name><index>[]</index></name>) <name>null</name></expr></argument>)</argument_list></call>.<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>new <name><name>byte</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>.<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a single raw binary</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>bits</name> =<init> <expr>new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>decoded</name> =<init> <expr><call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00000000".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00000001".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00000011".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00000111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00001111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00011111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"00111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"01111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"11111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a two raw binaries</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0000000011111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0000000111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0000001111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0000011111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0000111111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0001111111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0011111111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"0111111111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>decoded</name> = <call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>"1111111111111111".<call><name>getBytes</name><argument_list>(<argument><expr><name><name>Charsets</name>.<name>UTF_8</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <call><name>String</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>BinaryCodec</name>.<name>fromAscii</name></name><argument_list>(<argument><expr>(<name><name>byte</name><index>[]</index></name>) <name>null</name></expr></argument>)</argument_list></call>.<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="line">//</comment>
    <comment type="line">// Test encode(byte[])</comment>
    <comment type="line">//</comment>
    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="block">/*
     * Tests for byte[] encode(byte[])
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testEncodeByteArray</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// With a single raw binary</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>bits</name> =<init> <expr>new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>l_encoded</name> =<init> <expr>new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000000"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000001"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000011"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00001111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00011111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"01111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"11111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a two raw binaries</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000000"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000001"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000011"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000001111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000011111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000001111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000011111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// work on the other byte now</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000001111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000011111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0001111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0011111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0111111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"1111111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name><name>byte</name><index>[]</index></name>) <name>null</name></expr></argument>)</argument_list></call>.<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="line">//</comment>
    <comment type="line">// Test toAsciiBytes</comment>
    <comment type="line">//</comment>
    <comment type="line">// ------------------------------------------------------------------------</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testToAsciiBytes</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// With a single raw binary</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>bits</name> =<init> <expr>new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>l_encoded</name> =<init> <expr>new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000000"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000001"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000011"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00001111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00011111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"01111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"11111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a two raw binaries</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000000"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000001"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000011"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000001111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000011111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000001111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000011111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// work on the other byte now</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000001111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000011111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0001111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0011111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0111111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"1111111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiBytes</name></name><argument_list>(<argument><expr>(<name><name>byte</name><index>[]</index></name>) <name>null</name></expr></argument>)</argument_list></call>.<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="line">//</comment>
    <comment type="line">// Test toAsciiChars</comment>
    <comment type="line">//</comment>
    <comment type="line">// ------------------------------------------------------------------------</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testToAsciiChars</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// With a single raw binary</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>bits</name> =<init> <expr>new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>l_encoded</name> =<init> <expr>new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000000"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000001"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000011"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00001111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00011111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"01111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"11111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a two raw binaries</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000000"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000001"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000011"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000001111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000011111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000001111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000011111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// work on the other byte now</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000001111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000011111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0001111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0011111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0111111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"1111111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>BinaryCodec</name>.<name>toAsciiChars</name></name><argument_list>(<argument><expr>(<name><name>byte</name><index>[]</index></name>) <name>null</name></expr></argument>)</argument_list></call>.<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="line">//</comment>
    <comment type="line">// Test toAsciiString</comment>
    <comment type="line">//</comment>
    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="javadoc">/**
     * Tests the toAsciiString(byte[]) method
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testToAsciiString</name><parameter_list>()</parameter_list> <block>{
        <comment type="line">// With a single raw binary</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>bits</name> =<init> <expr>new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>l_encoded</name> =<init> <expr><call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000000"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000001"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000011"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00001111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00011111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"01111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"11111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a two raw binaries</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000000"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000001"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000011"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000001111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000011111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000001111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000011111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// work on the other byte now</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000001111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000011111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0001111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0011111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0111111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = <call><name><name>BinaryCodec</name>.<name>toAsciiString</name></name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"1111111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="line">//</comment>
    <comment type="line">// Test encode(Object)</comment>
    <comment type="line">//</comment>
    <comment type="line">// ------------------------------------------------------------------------</comment>
    <comment type="block">/*
     * Tests for Object encode(Object)
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testEncodeObjectNull</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name> =<init> <expr>new <name><name>byte</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>((<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>).<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * Tests for Object encode(Object)
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testEncodeObjectException</name><parameter_list>()</parameter_list> <block>{
        <try>try <block>{
            <expr_stmt><expr><call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> <catch>catch (<param><decl><type><specifier>final</specifier> <name>EncoderException</name></type> <name>e</name></decl></param>) <block>{
            <comment type="line">// all is well.</comment>
            <return>return;</return>
        }</block></catch></try>
        <expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr>"Expected EncoderException"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * Tests for Object encode(Object)
     */</comment>
    <function><type><annotation>@<name>Test</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>testEncodeObject</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{
        <comment type="line">// With a single raw binary</comment>
        <decl_stmt><decl><type><name>byte</name><index>[]</index></type> <name>bits</name> =<init> <expr>new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>l_encoded</name> =<init> <expr>new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000000"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000001"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000011"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00000111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00001111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00011111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"00111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"01111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"11111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// With a two raw binaries</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000000"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000001"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000011"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000000111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000001111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000011111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000000111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000001111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000011111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// work on the other byte now</comment>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000000111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000001111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000011111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0000111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0001111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0011111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"0111111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = new <name><name>byte</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>0</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bits</name><index>[<expr>1</expr>]</index></name> = <call>(<name>byte</name>) <argument_list>(<argument><expr><name>BIT_0</name> | <name>BIT_1</name> | <name>BIT_2</name> | <name>BIT_3</name> | <name>BIT_4</name> | <name>BIT_5</name> | <name>BIT_6</name> | <name>BIT_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_encoded</name> = new <call><name>String</name><argument_list>(<argument><expr>(<name><name>char</name><index>[]</index></name>) <call><name><name>instance</name>.<name>encode</name></name><argument_list>(<argument><expr>(<name>Object</name>) <name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr>"1111111111111111"</expr></argument>, <argument><expr><name>l_encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>
}</block></class>
</unit>
