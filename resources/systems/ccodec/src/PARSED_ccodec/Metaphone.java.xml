<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\David\IdeaProjects\arem\resources\systems\ccodec\src\main\java\org\apache\commons\codec\language\Metaphone.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>language</name></name>;</package>

<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>EncoderException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>StringEncoder</name></name>;</import>

<comment type="javadoc">/**
 * Encodes a string into a Metaphone value.
 * &lt;p&gt;
 * Initial Java implementation by &lt;CITE&gt;William B. Brogden. December, 1997&lt;/CITE&gt;.
 * Permission given by &lt;CITE&gt;wbrogden&lt;/CITE&gt; for code to be used anywhere.
 * &lt;p&gt;
 * &lt;CITE&gt;Hanging on the Metaphone&lt;/CITE&gt; by &lt;CITE&gt;Lawrence Philips&lt;/CITE&gt; in &lt;CITE&gt;Computer Language of Dec. 1990,
 * p 39.&lt;/CITE&gt;
 * &lt;p&gt;
 * Note, that this does not match the algorithm that ships with PHP, or the algorithm found in the Perl implementations:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;a href="http://search.cpan.org/~mschwern/Text-Metaphone-1.96/Metaphone.pm"&gt;Text:Metaphone-1.96&lt;/a&gt;
 *  (broken link 4/30/2013) &lt;/li&gt;
 * &lt;li&gt;&lt;a href="https://metacpan.org/source/MSCHWERN/Text-Metaphone-1.96//Metaphone.pm"&gt;Text:Metaphone-1.96&lt;/a&gt;
 *  (link checked 4/30/2013) &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * They have had undocumented changes from the originally published algorithm.
 * For more information, see &lt;a href="https://issues.apache.org/jira/browse/CODEC-57"&gt;CODEC-57&lt;/a&gt;.
 * &lt;p&gt;
 * This class is conditionally thread-safe.
 * The instance field {@link #maxCodeLen} is mutable {@link #setMaxCodeLen(int)}
 * but is not volatile, and accesses are not synchronized.
 * If an instance of the class is shared between threads, the caller needs to ensure that suitable synchronization
 * is used to ensure safe publication of the value between threads, and must not invoke {@link #setMaxCodeLen(int)}
 * after initial setup.
 *
 * @version $Id: Metaphone.java 1542813 2013-11-17 20:52:32Z tn $
 */</comment>
<class><specifier>public</specifier> class <name>Metaphone</name> <super><implements>implements <name>StringEncoder</name></implements></super> <block>{

    <comment type="javadoc">/**
     * Five values in the English language
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>VOWELS</name> =<init> <expr>"AEIOU"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Variable used in Metaphone algorithm
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>FRONTV</name> =<init> <expr>"EIY"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Variable used in Metaphone algorithm
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>VARSON</name> =<init> <expr>"CSPTG"</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * The max code length for metaphone is 4
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>maxCodeLen</name> =<init> <expr>4</expr></init></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Creates an instance of the Metaphone encoder
     */</comment>
    <constructor><specifier>public</specifier> <name>Metaphone</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Find the metaphone value of a String. This is similar to the
     * soundex algorithm, but better at finding similar sounding words.
     * All input is converted to upper case.
     * Limitations: Input format is expected to be a single ASCII word
     * with only characters in the A - Z range, no punctuation or numbers.
     *
     * @param txt String to find the metaphone code for
     * @return A metaphone code corresponding to the String supplied
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>metaphone</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>txt</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>hard</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>txt</name> == <name>null</name> || <call><name><name>txt</name>.<name>length</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
            <return>return <expr>""</expr>;</return>
        }</block></then></if>
        <comment type="line">// single character is itself</comment>
        <if>if <condition>(<expr><call><name><name>txt</name>.<name>length</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>txt</name>.<name>toUpperCase</name></name><argument_list>(<argument><expr><name><name>java</name>.<name>util</name>.<name>Locale</name>.<name>ENGLISH</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>char</name><index>[]</index></type> <name>inwd</name> =<init> <expr><call><name><name>txt</name>.<name>toUpperCase</name></name><argument_list>(<argument><expr><name><name>java</name>.<name>util</name>.<name>Locale</name>.<name>ENGLISH</name></name></expr></argument>)</argument_list></call>.<call><name>toCharArray</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>local</name> =<init> <expr>new <call><name>StringBuilder</name><argument_list>(<argument><expr>40</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// manipulate</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>code</name> =<init> <expr>new <call><name>StringBuilder</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">//   output</comment>
        <comment type="line">// handle initial 2 characters exceptions</comment>
        <switch>switch<condition>(<expr><name><name>inwd</name><index>[<expr>0</expr>]</index></name></expr>)</condition> <block>{
        <case>case <expr>'K'</expr>:
        </case><case>case <expr>'G'</expr>:
        </case><case>case <expr>'P'</expr>: <comment type="block">/* looking for KN, etc*/</comment>
            <if>if <condition>(<expr><name><name>inwd</name><index>[<expr>1</expr>]</index></name> == 'N'</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>local</name>.<name>append</name></name><argument_list>(<argument><expr><name>inwd</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>inwd</name>.<name>length</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>local</name>.<name>append</name></name><argument_list>(<argument><expr><name>inwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <break>break;</break>
        </case><case>case <expr>'A'</expr>: <comment type="block">/* looking for AE */</comment>
            <if>if <condition>(<expr><name><name>inwd</name><index>[<expr>1</expr>]</index></name> == 'E'</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>local</name>.<name>append</name></name><argument_list>(<argument><expr><name>inwd</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>inwd</name>.<name>length</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>local</name>.<name>append</name></name><argument_list>(<argument><expr><name>inwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <break>break;</break>
        </case><case>case <expr>'W'</expr>: <comment type="block">/* looking for WR or WH */</comment>
            <if>if <condition>(<expr><name><name>inwd</name><index>[<expr>1</expr>]</index></name> == 'R'</expr>)</condition><then> <block>{   <comment type="line">// WR -&gt; R</comment>
                <expr_stmt><expr><call><name><name>local</name>.<name>append</name></name><argument_list>(<argument><expr><name>inwd</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>inwd</name>.<name>length</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>inwd</name><index>[<expr>1</expr>]</index></name> == 'H'</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>local</name>.<name>append</name></name><argument_list>(<argument><expr><name>inwd</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>inwd</name>.<name>length</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>local</name>.<name>setCharAt</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>'W'</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// WH -&gt; W</comment>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name><name>local</name>.<name>append</name></name><argument_list>(<argument><expr><name>inwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <break>break;</break>
        </case><case>case <expr>'X'</expr>: <comment type="block">/* initial X becomes S */</comment>
            <expr_stmt><expr><name><name>inwd</name><index>[<expr>0</expr>]</index></name> = 'S'</expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>local</name>.<name>append</name></name><argument_list>(<argument><expr><name>inwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><default>default:
            <expr_stmt><expr><call><name><name>local</name>.<name>append</name></name><argument_list>(<argument><expr><name>inwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch> <comment type="line">// now local has working string with initials fixed</comment>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>wdsz</name> =<init> <expr><call><name><name>local</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><call><name><name>code</name>.<name>length</name></name><argument_list>()</argument_list></call> &lt; <call><name><name>this</name>.<name>getMaxCodeLen</name></name><argument_list>()</argument_list></call> &amp;&amp;
               <name>n</name> &lt; <name>wdsz</name></expr> )</condition> <block>{ <comment type="line">// max code size of 4 works well</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>char</name></type> <name>symb</name> =<init> <expr><call><name><name>local</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// remove duplicate letters except C</comment>
            <if>if <condition>(<expr><name>symb</name> != 'C' &amp;&amp; <call><name>isPreviousChar</name><argument_list>( <argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>symb</name></expr></argument> )</argument_list></call></expr> )</condition><then> <block>{
                <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
            }</block></then> <else>else <block>{ <comment type="line">// not dup</comment>
                <switch>switch<condition>(<expr><name>symb</name></expr>)</condition> <block>{
                <case>case <expr>'A'</expr>:
                </case><case>case <expr>'E'</expr>:
                </case><case>case <expr>'I'</expr>:
                </case><case>case <expr>'O'</expr>:
                </case><case>case <expr>'U'</expr>:
                    <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr><name>symb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <break>break;</break> <comment type="line">// only use vowel if leading char</comment>
                </case><case>case <expr>'B'</expr>:
                    <if>if <condition>( <expr><call><name>isPreviousChar</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>'M'</expr></argument>)</argument_list></call> &amp;&amp;
                         <call><name>isLastChar</name><argument_list>(<argument><expr><name>wdsz</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr> )</condition><then> <block>{ <comment type="line">// B is silent if word ends in MB</comment>
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr><name>symb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>'C'</expr>: <comment type="line">// lots of C special cases</comment>
                    <comment type="block">/* discard if SCI, SCE or SCY */</comment>
                    <if>if <condition>( <expr><call><name>isPreviousChar</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>'S'</expr></argument>)</argument_list></call> &amp;&amp;
                         !<call><name>isLastChar</name><argument_list>(<argument><expr><name>wdsz</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> &amp;&amp;
                         <call><name><name>FRONTV</name>.<name>indexOf</name></name><argument_list>(<argument><expr><call><name><name>local</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>n</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;= 0</expr> )</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                    <if>if <condition>(<expr><call><name>regionMatch</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>"CIA"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// "CIA" -&gt; X</comment>
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                    <if>if <condition>(<expr>!<call><name>isLastChar</name><argument_list>(<argument><expr><name>wdsz</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> &amp;&amp;
                        <call><name><name>FRONTV</name>.<name>indexOf</name></name><argument_list>(<argument><expr><call><name><name>local</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>n</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break> <comment type="line">// CI,CE,CY -&gt; S</comment>
                    }</block></then></if>
                    <if>if <condition>(<expr><call><name>isPreviousChar</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>'S'</expr></argument>)</argument_list></call> &amp;&amp;
                        <call><name>isNextChar</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>'H'</expr></argument>)</argument_list></call></expr> )</condition><then> <block>{ <comment type="line">// SCH-&gt;sk</comment>
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'K'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                    <if>if <condition>(<expr><call><name>isNextChar</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>'H'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// detect CH</comment>
                        <if>if <condition>(<expr><name>n</name> == 0 &amp;&amp;
                            <name>wdsz</name> &gt;= 3 &amp;&amp;
                            <call><name>isVowel</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr>2</expr></argument>)</argument_list></call></expr> )</condition><then> <block>{ <comment type="line">// CH consonant -&gt; K consonant</comment>
                            <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'K'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// CHvowel -&gt; X</comment>
                        }</block></else></if>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'K'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <break>break;</break>
                </case><case>case <expr>'D'</expr>:
                    <if>if <condition>(<expr>!<call><name>isLastChar</name><argument_list>(<argument><expr><name>wdsz</name></expr></argument>, <argument><expr><name>n</name> + 1</expr></argument>)</argument_list></call> &amp;&amp;
                        <call><name>isNextChar</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>'G'</expr></argument>)</argument_list></call> &amp;&amp;
                        <call><name><name>FRONTV</name>.<name>indexOf</name></name><argument_list>(<argument><expr><call><name><name>local</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>n</name> + 2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition><then> <block>{ <comment type="line">// DGE DGI DGY -&gt; J</comment>
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'J'</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>n</name> += 2</expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <break>break;</break>
                </case><case>case <expr>'G'</expr>: <comment type="line">// GH silent at end or before consonant</comment>
                    <if>if <condition>(<expr><call><name>isLastChar</name><argument_list>(<argument><expr><name>wdsz</name></expr></argument>, <argument><expr><name>n</name> + 1</expr></argument>)</argument_list></call> &amp;&amp;
                        <call><name>isNextChar</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>'H'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                    <if>if <condition>(<expr>!<call><name>isLastChar</name><argument_list>(<argument><expr><name>wdsz</name></expr></argument>, <argument><expr><name>n</name> + 1</expr></argument>)</argument_list></call> &amp;&amp;
                        <call><name>isNextChar</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr>'H'</expr></argument>)</argument_list></call> &amp;&amp;
                        !<call><name>isVowel</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name>+2</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp;
                        ( <call><name>regionMatch</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>"GN"</expr></argument>)</argument_list></call> ||
                          <call><name>regionMatch</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>"GNED"</expr></argument>)</argument_list></call> )</expr> )</condition><then> <block>{
                        <break>break;</break> <comment type="line">// silent G</comment>
                    }</block></then></if>
                    <if>if <condition>(<expr><call><name>isPreviousChar</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>'G'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="line">// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true</comment>
                        <expr_stmt><expr><name>hard</name> = true</expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><name>hard</name> = false</expr>;</expr_stmt>
                    }</block></else></if>
                    <if>if <condition>(<expr>!<call><name>isLastChar</name><argument_list>(<argument><expr><name>wdsz</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> &amp;&amp;
                        <call><name><name>FRONTV</name>.<name>indexOf</name></name><argument_list>(<argument><expr><call><name><name>local</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>n</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;= 0 &amp;&amp;
                        !<name>hard</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'J'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'K'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <break>break;</break>
                </case><case>case <expr>'H'</expr>:
                    <if>if <condition>(<expr><call><name>isLastChar</name><argument_list>(<argument><expr><name>wdsz</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <break>break;</break> <comment type="line">// terminal H</comment>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp;
                        <call><name><name>VARSON</name>.<name>indexOf</name></name><argument_list>(<argument><expr><call><name><name>local</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>n</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                    <if>if <condition>(<expr><call><name>isVowel</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'H'</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Hvowel</comment>
                    }</block></then></if>
                    <break>break;</break>
                </case><case>case <expr>'F'</expr>:
                </case><case>case <expr>'J'</expr>:
                </case><case>case <expr>'L'</expr>:
                </case><case>case <expr>'M'</expr>:
                </case><case>case <expr>'N'</expr>:
                </case><case>case <expr>'R'</expr>:
                    <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr><name>symb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>'K'</expr>:
                    <if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then> <block>{ <comment type="line">// not initial</comment>
                        <if>if <condition>(<expr>!<call><name>isPreviousChar</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>'C'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr><name>symb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr><name>symb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// initial K</comment>
                    }</block></else></if>
                    <break>break;</break>
                </case><case>case <expr>'P'</expr>:
                    <if>if <condition>(<expr><call><name>isNextChar</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr>'H'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="line">// PH -&gt; F</comment>
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr><name>symb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <break>break;</break>
                </case><case>case <expr>'Q'</expr>:
                    <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'K'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>'S'</expr>:
                    <if>if <condition>(<expr><call><name>regionMatch</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr>"SH"</expr></argument>)</argument_list></call> ||
                        <call><name>regionMatch</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr>"SIO"</expr></argument>)</argument_list></call> ||
                        <call><name>regionMatch</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr>"SIA"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <break>break;</break>
                </case><case>case <expr>'T'</expr>:
                    <if>if <condition>(<expr><call><name>regionMatch</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr>"TIA"</expr></argument>)</argument_list></call> ||
                        <call><name>regionMatch</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr>"TIO"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                    <if>if <condition>(<expr><call><name>regionMatch</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr>"TCH"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="line">// Silent if in "TCH"</comment>
                        <break>break;</break>
                    }</block></then></if>
                    <comment type="line">// substitute numeral 0 for TH (resembles theta after all)</comment>
                    <if>if <condition>(<expr><call><name>regionMatch</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr>"TH"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <break>break;</break>
                </case><case>case <expr>'V'</expr>:
                    <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr>'W'</expr>:
                </case><case>case <expr>'Y'</expr>: <comment type="line">// silent if not followed by vowel</comment>
                    <if>if <condition>(<expr>!<call><name>isLastChar</name><argument_list>(<argument><expr><name>wdsz</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call> &amp;&amp;
                        <call><name>isVowel</name><argument_list>(<argument><expr><name>local</name></expr></argument>,<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr><name>symb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <break>break;</break>
                </case><case>case <expr>'X'</expr>:
                    <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'K'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr>'Z'</expr>:
                    <expr_stmt><expr><call><name><name>code</name>.<name>append</name></name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><default>default:
                    <comment type="line">// do nothing</comment>
                    <break>break;</break>
                </default>}</block></switch> <comment type="line">// end switch</comment>
                <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
            }</block></else></if> <comment type="line">// end else from symb != 'C'</comment>
            <if>if <condition>(<expr><call><name><name>code</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; <call><name><name>this</name>.<name>getMaxCodeLen</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>code</name>.<name>setLength</name></name><argument_list>(<argument><expr><call><name><name>this</name>.<name>getMaxCodeLen</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>
        <return>return <expr><call><name><name>code</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isVowel</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>string</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>VOWELS</name>.<name>indexOf</name></name><argument_list>(<argument><expr><call><name><name>string</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isPreviousChar</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>string</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>matches</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>index</name> &gt; 0 &amp;&amp;
            <name>index</name> &lt; <call><name><name>string</name>.<name>length</name></name><argument_list>()</argument_list></call></expr> )</condition><then> <block>{
            <expr_stmt><expr><name>matches</name> = <call><name><name>string</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>index</name> - 1</expr></argument>)</argument_list></call> == <name>c</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>matches</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isNextChar</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>string</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>matches</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>index</name> &gt;= 0 &amp;&amp;
            <name>index</name> &lt; <call><name><name>string</name>.<name>length</name></name><argument_list>()</argument_list></call> - 1</expr> )</condition><then> <block>{
            <expr_stmt><expr><name>matches</name> = <call><name><name>string</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>index</name> + 1</expr></argument>)</argument_list></call> == <name>c</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>matches</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>regionMatch</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>string</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>test</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>matches</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>index</name> &gt;= 0 &amp;&amp;
            <name>index</name> + <call><name><name>test</name>.<name>length</name></name><argument_list>()</argument_list></call> - 1 &lt; <call><name><name>string</name>.<name>length</name></name><argument_list>()</argument_list></call></expr> )</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>substring</name> =<init> <expr><call><name><name>string</name>.<name>substring</name></name><argument_list>( <argument><expr><name>index</name></expr></argument>, <argument><expr><name>index</name> + <call><name><name>test</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>matches</name> = <call><name><name>substring</name>.<name>equals</name></name><argument_list>( <argument><expr><name>test</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>matches</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isLastChar</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>wdsz</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name>n</name> + 1 == <name>wdsz</name></expr>;</return>
    }</block></function>


    <comment type="javadoc">/**
     * Encodes an Object using the metaphone algorithm.  This method
     * is provided in order to satisfy the requirements of the
     * Encoder interface, and will throw an EncoderException if the
     * supplied object is not of type java.lang.String.
     *
     * @param obj Object to encode
     * @return An object (or type java.lang.String) containing the
     *         metaphone code which corresponds to the String supplied.
     * @throws EncoderException if the parameter supplied is not
     *                          of type java.lang.String
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>Object</name></type> <name>encode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Object</name></type> <name>obj</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>EncoderException</name></expr></argument></throws> <block>{
        <if>if <condition>(<expr>!(<name>obj</name> <name>instanceof</name> <name>String</name>)</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>EncoderException</name><argument_list>(<argument><expr>"Parameter supplied to Metaphone encode is not of type java.lang.String"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name>metaphone</name><argument_list>(<argument><expr>(<name>String</name>) <name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes a String using the Metaphone algorithm.
     *
     * @param str String object to encode
     * @return The metaphone code corresponding to the String supplied
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>String</name></type> <name>encode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>str</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>metaphone</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Tests is the metaphones of two strings are identical.
     *
     * @param str1 First of two strings to compare
     * @param str2 Second of two strings to compare
     * @return {@code true} if the metaphones of these strings are identical,
     *        {@code false} otherwise.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isMetaphoneEqual</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>str1</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>str2</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>metaphone</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><call><name>metaphone</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Returns the maxCodeLen.
     * @return int
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMaxCodeLen</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name><name>this</name>.<name>maxCodeLen</name></name></expr>;</return> }</block></function>

    <comment type="javadoc">/**
     * Sets the maxCodeLen.
     * @param maxCodeLen The maxCodeLen to set
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMaxCodeLen</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxCodeLen</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name><name>this</name>.<name>maxCodeLen</name></name> = <name>maxCodeLen</name></expr>;</expr_stmt> }</block></function>

}</block></class>
</unit>
