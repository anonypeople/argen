<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\David\IdeaProjects\arem\resources\systems\ccodec\src\main\java\org\apache\commons\codec\language\bm\PhoneticEngine.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>language</name>.<name>bm</name></name>;</package>

<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Arrays</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Collections</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>EnumMap</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashSet</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Iterator</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>LinkedHashSet</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Locale</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Map</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Set</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>TreeSet</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>language</name>.<name>bm</name>.<name>Languages</name>.<name>LanguageSet</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>language</name>.<name>bm</name>.<name>Rule</name>.<name>Phoneme</name></name>;</import>

<comment type="javadoc">/**
 * Converts words into potential phonetic representations.
 * &lt;p&gt;
 * This is a two-stage process. Firstly, the word is converted into a phonetic representation that takes
 * into account the likely source language. Next, this phonetic representation is converted into a
 * pan-European 'average' representation, allowing comparison between different versions of essentially
 * the same word from different languages.
 * &lt;p&gt;
 * This class is intentionally immutable and thread-safe.
 * If you wish to alter the settings for a PhoneticEngine, you
 * must make a new one with the updated settings.
 * &lt;p&gt;
 * Ported from phoneticengine.php
 *
 * @since 1.6
 * @version $Id: PhoneticEngine.java 1549875 2013-12-10 15:54:15Z ggregory $
 */</comment>
<class><specifier>public</specifier> class <name>PhoneticEngine</name> <block>{

    <comment type="javadoc">/**
     * Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside
     * this package, and probably not outside the {@link PhoneticEngine} class.
     *
     * @since 1.6
     */</comment>
    <class><specifier>static</specifier> <specifier>final</specifier> class <name>PhonemeBuilder</name> <block>{

        <comment type="javadoc">/**
         * An empty builder where all phonemes must come from some set of languages. This will contain a single
         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new
         * phoneme from scratch.
         *
         * @param languages the set of languages
         * @return  a new, empty phoneme builder
         */</comment>
        <function><type><specifier>public</specifier> <specifier>static</specifier> <name>PhonemeBuilder</name></type> <name>empty</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Languages</name>.<name>LanguageSet</name></name></type> <name>languages</name></decl></param>)</parameter_list> <block>{
            <return>return <expr>new <call><name>PhonemeBuilder</name><argument_list>(<argument><expr>new <call><name><name>Rule</name>.<name>Phoneme</name></name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>languages</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name><name>Rule</name>.<name>Phoneme</name></name></argument>&gt;</argument_list></name></type> <name>phonemes</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>PhonemeBuilder</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Rule</name>.<name>Phoneme</name></name></type> <name>phoneme</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>phonemes</name></name> = new <call><name><name>LinkedHashSet</name><argument_list>&lt;<argument><name><name>Rule</name>.<name>Phoneme</name></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name>.<name>phonemes</name>.<name>add</name></name><argument_list>(<argument><expr><name>phoneme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <constructor><specifier>private</specifier> <name>PhonemeBuilder</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name><name>Rule</name>.<name>Phoneme</name></name></argument>&gt;</argument_list></name></type> <name>phonemes</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>phonemes</name></name> = <name>phonemes</name></expr>;</expr_stmt>
        }</block></constructor>

        <comment type="javadoc">/**
         * Creates a new phoneme builder containing all phonemes in this one extended by &lt;code&gt;str&lt;/code&gt;.
         *
         * @param str   the characters to append to the phonemes
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>append</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></param>)</parameter_list> <block>{
            <for>for (<init><decl><type><specifier>final</specifier> <name><name>Rule</name>.<name>Phoneme</name></name></type> <name>ph</name> :<range> <expr><name><name>this</name>.<name>phonemes</name></name></expr></range></decl></init>) <block>{
                <expr_stmt><expr><call><name><name>ph</name>.<name>append</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></function>

        <comment type="javadoc">/**
         * Applies the given phoneme expression to all phonemes in this phoneme builder.
         * &lt;p&gt;
         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are
         * incompatible.
         *
         * @param phonemeExpr   the expression to apply
         * @param maxPhonemes   the maximum number of phonemes to build up
         */</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>apply</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Rule</name>.<name>PhonemeExpr</name></name></type> <name>phonemeExpr</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxPhonemes</name></decl></param>)</parameter_list> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name><name>Rule</name>.<name>Phoneme</name></name></argument>&gt;</argument_list></name></type> <name>newPhonemes</name> =<init> <expr>new <call><name><name>LinkedHashSet</name><argument_list>&lt;<argument><name><name>Rule</name>.<name>Phoneme</name></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>maxPhonemes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <label><name>EXPR</name>:</label> <for>for (<init><decl><type><specifier>final</specifier> <name><name>Rule</name>.<name>Phoneme</name></name></type> <name>left</name> :<range> <expr><name><name>this</name>.<name>phonemes</name></name></expr></range></decl></init>) <block>{
                <for>for (<init><decl><type><specifier>final</specifier> <name><name>Rule</name>.<name>Phoneme</name></name></type> <name>right</name> :<range> <expr><call><name><name>phonemeExpr</name>.<name>getPhonemes</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>LanguageSet</name></type> <name>languages</name> =<init> <expr><call><name><name>left</name>.<name>getLanguages</name></name><argument_list>()</argument_list></call>.<call><name>restrictTo</name><argument_list>(<argument><expr><call><name><name>right</name>.<name>getLanguages</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<call><name><name>languages</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Rule</name>.<name>Phoneme</name></name></type> <name>join</name> =<init> <expr>new <call><name>Phoneme</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>languages</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name><name>newPhonemes</name>.<name>size</name></name><argument_list>()</argument_list></call> &lt; <name>maxPhonemes</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name><name>newPhonemes</name>.<name>add</name></name><argument_list>(<argument><expr><name>join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if>if <condition>(<expr><call><name><name>newPhonemes</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt;= <name>maxPhonemes</name></expr>)</condition><then> <block>{
                                <break>break EXPR;</break>
                            }</block></then></if>
                        }</block></then></if>
                    }</block></then></if>
                }</block></for>
            }</block></for>

            <expr_stmt><expr><call><name><name>this</name>.<name>phonemes</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name>.<name>phonemes</name>.<name>addAll</name></name><argument_list>(<argument><expr><name>newPhonemes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="javadoc">/**
         * Gets underlying phoneme set. Please don't mutate.
         *
         * @return  the phoneme set
         */</comment>
        <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name><name>Rule</name>.<name>Phoneme</name></name></argument>&gt;</argument_list></name></type> <name>getPhonemes</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>this</name>.<name>phonemes</name></name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,
         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially
         * expensive operation, which should be avoided when debugging.
         *
         * @return  the stringified phoneme set
         */</comment>
        <function><type><specifier>public</specifier> <name>String</name></type> <name>makeString</name><parameter_list>()</parameter_list> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>sb</name> =<init> <expr>new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><specifier>final</specifier> <name><name>Rule</name>.<name>Phoneme</name></name></type> <name>ph</name> :<range> <expr><name><name>this</name>.<name>phonemes</name></name></expr></range></decl></init>) <block>{
                <if>if <condition>(<expr><call><name><name>sb</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>"|"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>ph</name>.<name>getPhonemeText</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><call><name><name>sb</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * A function closure capturing the application of a list of rules to an input sequence at a particular offset.
     * After invocation, the values &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;found&lt;/code&gt; are updated. &lt;code&gt;i&lt;/code&gt; points to the
     * index of the next char in &lt;code&gt;input&lt;/code&gt; that must be processed next (the input up to that index having been
     * processed already), and &lt;code&gt;found&lt;/code&gt; indicates if a matching rule was found or not. In the case where a
     * matching rule was found, &lt;code&gt;phonemeBuilder&lt;/code&gt; is replaced with a new builder containing the phonemes
     * updated by the matching rule.
     *
     * Although this class is not thread-safe (it has mutable unprotected fields), it is not shared between threads
     * as it is constructed as needed by the calling methods.
     * @since 1.6
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>RulesApplication</name> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>finalRules</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <name>PhonemeBuilder</name></type> <name>phonemeBuilder</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>maxPhonemes</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>found</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>RulesApplication</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>finalRules</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>,
                                <param><decl><type><specifier>final</specifier> <name>PhonemeBuilder</name></type> <name>phonemeBuilder</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>i</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxPhonemes</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr><name>finalRules</name> == <name>null</name></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>NullPointerException</name><argument_list>(<argument><expr>"The finalRules argument must not be null"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <expr_stmt><expr><name><name>this</name>.<name>finalRules</name></name> = <name>finalRules</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>phonemeBuilder</name></name> = <name>phonemeBuilder</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>input</name></name> = <name>input</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>i</name></name> = <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>maxPhonemes</name></name> = <name>maxPhonemes</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>int</name></type> <name>getI</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>this</name>.<name>i</name></name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>PhonemeBuilder</name></type> <name>getPhonemeBuilder</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>this</name>.<name>phonemeBuilder</name></name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context
         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no
         * match, &lt;code&gt;i&lt;/code&gt; is advanced one and the character is silently dropped from the phonetic spelling.
         *
         * @return &lt;code&gt;this&lt;/code&gt;
         */</comment>
        <function><type><specifier>public</specifier> <name>RulesApplication</name></type> <name>invoke</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>found</name></name> = false</expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>patternLength</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></type> <name>rules</name> =<init> <expr><call><name><name>this</name>.<name>finalRules</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>input</name>.<name>subSequence</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name>+<name>patternLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>rules</name> != <name>null</name></expr>)</condition><then> <block>{
                <for>for (<init><decl><type><specifier>final</specifier> <name>Rule</name></type> <name>rule</name> :<range> <expr><name>rules</name></expr></range></decl></init>) <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>pattern</name> =<init> <expr><call><name><name>rule</name>.<name>getPattern</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>patternLength</name> = <call><name><name>pattern</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name><name>rule</name>.<name>patternAndContextMatches</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>input</name></name></expr></argument>, <argument><expr><name><name>this</name>.<name>i</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>this</name>.<name>phonemeBuilder</name>.<name>apply</name></name><argument_list>(<argument><expr><call><name><name>rule</name>.<name>getPhoneme</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>maxPhonemes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>this</name>.<name>found</name></name> = true</expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                }</block></for>
            }</block></then></if>

            <if>if <condition>(<expr>!<name><name>this</name>.<name>found</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>patternLength</name> = 1</expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name><name>this</name>.<name>i</name></name> += <name>patternLength</name></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isFound</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>this</name>.<name>found</name></name></expr>;</return>
        }</block></function>
    }</block></class>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>NameType</name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>NAME_PREFIXES</name> =<init> <expr>new <call><name><name>EnumMap</name><argument_list>&lt;<argument><name>NameType</name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>NameType</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    static <block>{
        <expr_stmt><expr><call><name><name>NAME_PREFIXES</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>NameType</name>.<name>ASHKENAZI</name></name></expr></argument>,
                <argument><expr><call><name><name>Collections</name>.<name>unmodifiableSet</name></name><argument_list>(
                        <argument><expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr>"bar"</expr></argument>, <argument><expr>"ben"</expr></argument>, <argument><expr>"da"</expr></argument>, <argument><expr>"de"</expr></argument>, <argument><expr>"van"</expr></argument>, <argument><expr>"von"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>NAME_PREFIXES</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>NameType</name>.<name>SEPHARDIC</name></name></expr></argument>,
                <argument><expr><call><name><name>Collections</name>.<name>unmodifiableSet</name></name><argument_list>(
                        <argument><expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr>"al"</expr></argument>, <argument><expr>"el"</expr></argument>, <argument><expr>"da"</expr></argument>, <argument><expr>"dal"</expr></argument>, <argument><expr>"de"</expr></argument>, <argument><expr>"del"</expr></argument>, <argument><expr>"dela"</expr></argument>, <argument><expr>"de la"</expr></argument>,
                                                          <argument><expr>"della"</expr></argument>, <argument><expr>"des"</expr></argument>, <argument><expr>"di"</expr></argument>, <argument><expr>"do"</expr></argument>, <argument><expr>"dos"</expr></argument>, <argument><expr>"du"</expr></argument>, <argument><expr>"van"</expr></argument>, <argument><expr>"von"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>NAME_PREFIXES</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>NameType</name>.<name>GENERIC</name></name></expr></argument>,
                <argument><expr><call><name><name>Collections</name>.<name>unmodifiableSet</name></name><argument_list>(
                        <argument><expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr>"da"</expr></argument>, <argument><expr>"dal"</expr></argument>, <argument><expr>"de"</expr></argument>, <argument><expr>"del"</expr></argument>, <argument><expr>"dela"</expr></argument>, <argument><expr>"de la"</expr></argument>, <argument><expr>"della"</expr></argument>,
                                                          <argument><expr>"des"</expr></argument>, <argument><expr>"di"</expr></argument>, <argument><expr>"do"</expr></argument>, <argument><expr>"dos"</expr></argument>, <argument><expr>"du"</expr></argument>, <argument><expr>"van"</expr></argument>, <argument><expr>"von"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>

    <comment type="javadoc">/**
     * Joins some strings with an internal separator.
     * @param strings   Strings to join
     * @param sep       String to separate them with
     * @return a single String consisting of each element of &lt;code&gt;strings&lt;/code&gt; interleaved by &lt;code&gt;sep&lt;/code&gt;
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>join</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>strings</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>sep</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>sb</name> =<init> <expr>new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>si</name> =<init> <expr><call><name><name>strings</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>si</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>si</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <while>while <condition>(<expr><call><name><name>si</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call>.<call><name>append</name><argument_list>(<argument><expr><call><name><name>si</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <return>return <expr><call><name><name>sb</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEFAULT_MAX_PHONEMES</name> =<init> <expr>20</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Lang</name></type> <name>lang</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>NameType</name></type> <name>nameType</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>RuleType</name></type> <name>ruleType</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>concat</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>maxPhonemes</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Generates a new, fully-configured phonetic engine.
     *
     * @param nameType
     *            the type of names it will use
     * @param ruleType
     *            the type of rules it will apply
     * @param concat
     *            if it will concatenate multiple encodings
     */</comment>
    <constructor><specifier>public</specifier> <name>PhoneticEngine</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>NameType</name></type> <name>nameType</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>RuleType</name></type> <name>ruleType</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>concat</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>nameType</name></expr></argument>, <argument><expr><name>ruleType</name></expr></argument>, <argument><expr><name>concat</name></expr></argument>, <argument><expr><name>DEFAULT_MAX_PHONEMES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Generates a new, fully-configured phonetic engine.
     *
     * @param nameType
     *            the type of names it will use
     * @param ruleType
     *            the type of rules it will apply
     * @param concat
     *            if it will concatenate multiple encodings
     * @param maxPhonemes
     *            the maximum number of phonemes that will be handled
     * @since 1.7
     */</comment>
    <constructor><specifier>public</specifier> <name>PhoneticEngine</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>NameType</name></type> <name>nameType</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>RuleType</name></type> <name>ruleType</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>concat</name></decl></param>,
                          <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxPhonemes</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>ruleType</name> == <name><name>RuleType</name>.<name>RULES</name></name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"ruleType must not be " + <name><name>RuleType</name>.<name>RULES</name></name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><name><name>this</name>.<name>nameType</name></name> = <name>nameType</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>ruleType</name></name> = <name>ruleType</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>concat</name></name> = <name>concat</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>lang</name></name> = <call><name><name>Lang</name>.<name>instance</name></name><argument_list>(<argument><expr><name>nameType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>maxPhonemes</name></name> = <name>maxPhonemes</name></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Applies the final rules to convert from a language-specific phonetic representation to a
     * language-independent representation.
     *
     * @param phonemeBuilder the current phonemes
     * @param finalRules the final rules to apply
     * @return the resulting phonemes
     */</comment>
    <function><type><specifier>private</specifier> <name>PhonemeBuilder</name></type> <name>applyFinalRules</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>PhonemeBuilder</name></type> <name>phonemeBuilder</name></decl></param>,
                                           <param><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>finalRules</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>finalRules</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>NullPointerException</name><argument_list>(<argument><expr>"finalRules can not be null"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>finalRules</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>phonemeBuilder</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name><name>Rule</name>.<name>Phoneme</name></name></argument>&gt;</argument_list></name></type> <name>phonemes</name> =<init> <expr>new <call><name><name>TreeSet</name><argument_list>&lt;<argument><name><name>Rule</name>.<name>Phoneme</name></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Rule</name>.<name>Phoneme</name>.<name>COMPARATOR</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><specifier>final</specifier> <name><name>Rule</name>.<name>Phoneme</name></name></type> <name>phoneme</name> :<range> <expr><call><name><name>phonemeBuilder</name>.<name>getPhonemes</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
            <decl_stmt><decl><type><name>PhonemeBuilder</name></type> <name>subBuilder</name> =<init> <expr><call><name><name>PhonemeBuilder</name>.<name>empty</name></name><argument_list>(<argument><expr><call><name><name>phoneme</name>.<name>getLanguages</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>phonemeText</name> =<init> <expr><call><name><name>phoneme</name>.<name>getPhonemeText</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>phonemeText</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>) <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>RulesApplication</name></type> <name>rulesApplication</name> =<init>
                        <expr>new <call><name>RulesApplication</name><argument_list>(<argument><expr><name>finalRules</name></expr></argument>, <argument><expr><name>phonemeText</name></expr></argument>, <argument><expr><name>subBuilder</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>maxPhonemes</name></expr></argument>)</argument_list></call>.<call><name>invoke</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>found</name> =<init> <expr><call><name><name>rulesApplication</name>.<name>isFound</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>subBuilder</name> = <call><name><name>rulesApplication</name>.<name>getPhonemeBuilder</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr>!<name>found</name></expr>)</condition><then> <block>{
                    <comment type="line">// not found, appending as-is</comment>
                    <expr_stmt><expr><call><name><name>subBuilder</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>phonemeText</name>.<name>subSequence</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <expr_stmt><expr><name>i</name> = <call><name><name>rulesApplication</name>.<name>getI</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <expr_stmt><expr><call><name><name>phonemes</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>subBuilder</name>.<name>getPhonemes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <return>return <expr>new <call><name>PhonemeBuilder</name><argument_list>(<argument><expr><name>phonemes</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes a string to its phonetic representation.
     *
     * @param input
     *            the String to encode
     * @return the encoding of the input
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>encode</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Languages</name>.<name>LanguageSet</name></name></type> <name>languageSet</name> =<init> <expr><call><name><name>this</name>.<name>lang</name>.<name>guessLanguages</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>encode</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>languageSet</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.
     *
     * @param input
     *            String to phoneticise; a String with dashes or spaces separating each word
     * @param languageSet
     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations
     *   of the input
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>encode</name><parameter_list>(<param><decl><type><name>String</name></type> <name>input</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>Languages</name>.<name>LanguageSet</name></name></type> <name>languageSet</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rules</name> =<init> <expr><call><name><name>Rule</name>.<name>getInstanceMap</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>nameType</name></name></expr></argument>, <argument><expr><name><name>RuleType</name>.<name>RULES</name></name></expr></argument>, <argument><expr><name>languageSet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// rules common across many (all) languages</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>finalRules1</name> =<init> <expr><call><name><name>Rule</name>.<name>getInstanceMap</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>nameType</name></name></expr></argument>, <argument><expr><name><name>this</name>.<name>ruleType</name></name></expr></argument>, <argument><expr>"common"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// rules that apply to a specific language that may be ambiguous or wrong if applied to other languages</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>finalRules2</name> =<init> <expr><call><name><name>Rule</name>.<name>getInstanceMap</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>nameType</name></name></expr></argument>, <argument><expr><name><name>this</name>.<name>ruleType</name></name></expr></argument>, <argument><expr><name>languageSet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// tidy the input</comment>
        <comment type="line">// lower case is a locale-dependent operation</comment>
        <expr_stmt><expr><name>input</name> = <call><name><name>input</name>.<name>toLowerCase</name></name><argument_list>(<argument><expr><name><name>Locale</name>.<name>ENGLISH</name></name></expr></argument>)</argument_list></call>.<call><name>replace</name><argument_list>(<argument><expr>'-'</expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call>.<call><name>trim</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>this</name>.<name>nameType</name></name> == <name><name>NameType</name>.<name>GENERIC</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt;= 2 &amp;&amp; <call><name><name>input</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr>"d'"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// check for d'</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>remainder</name> =<init> <expr><call><name><name>input</name>.<name>substring</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>combined</name> =<init> <expr>"d" + <name>remainder</name></expr></init></decl>;</decl_stmt>
                <return>return <expr>"(" + <call><name>encode</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call> + ")-(" + <call><name>encode</name><argument_list>(<argument><expr><name>combined</name></expr></argument>)</argument_list></call> + ")"</expr>;</return>
            }</block></then></if>
            <for>for (<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>l</name> :<range> <expr><call><name><name>NAME_PREFIXES</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>nameType</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>) <block>{
                <comment type="line">// handle generic prefixes</comment>
                <if>if <condition>(<expr><call><name><name>input</name>.<name>startsWith</name></name><argument_list>(<argument><expr><name>l</name> + " "</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="line">// check for any prefix in the words list</comment>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>remainder</name> =<init> <expr><call><name><name>input</name>.<name>substring</name></name><argument_list>(<argument><expr><call><name><name>l</name>.<name>length</name></name><argument_list>()</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// input without the prefix</comment>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>combined</name> =<init> <expr><name>l</name> + <name>remainder</name></expr></init></decl>;</decl_stmt> <comment type="line">// input with prefix without space</comment>
                    <return>return <expr>"(" + <call><name>encode</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call> + ")-(" + <call><name>encode</name><argument_list>(<argument><expr><name>combined</name></expr></argument>)</argument_list></call> + ")"</expr>;</return>
                }</block></then></if>
            }</block></for>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>words</name> =<init> <expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><call><name><name>input</name>.<name>split</name></name><argument_list>(<argument><expr>"\\s+"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>words2</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// special-case handling of word prefixes based upon the name type</comment>
        <switch>switch <condition>(<expr><name><name>this</name>.<name>nameType</name></name></expr>)</condition> <block>{
        <case>case <expr><name>SEPHARDIC</name></expr>:
            <for>for (<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>aWord</name> :<range> <expr><name>words</name></expr></range></decl></init>) <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name><index>[]</index></type> <name>parts</name> =<init> <expr><call><name><name>aWord</name>.<name>split</name></name><argument_list>(<argument><expr>"'"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>lastPart</name> =<init> <expr><name><name>parts</name><index>[<expr><name><name>parts</name>.<name>length</name></name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>words2</name>.<name>add</name></name><argument_list>(<argument><expr><name>lastPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name><name>words2</name>.<name>removeAll</name></name><argument_list>(<argument><expr><call><name><name>NAME_PREFIXES</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>nameType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>ASHKENAZI</name></expr>:
            <expr_stmt><expr><call><name><name>words2</name>.<name>addAll</name></name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>words2</name>.<name>removeAll</name></name><argument_list>(<argument><expr><call><name><name>NAME_PREFIXES</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>nameType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>GENERIC</name></expr>:
            <expr_stmt><expr><call><name><name>words2</name>.<name>addAll</name></name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><default>default:
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Unreachable case: " + <name><name>this</name>.<name>nameType</name></name></expr></argument>)</argument_list></call></expr>;</throw>
        </default>}</block></switch>

        <if>if <condition>(<expr><name><name>this</name>.<name>concat</name></name></expr>)</condition><then> <block>{
            <comment type="line">// concat mode enabled</comment>
            <expr_stmt><expr><name>input</name> = <call><name>join</name><argument_list>(<argument><expr><name>words2</name></expr></argument>, <argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name><name>words2</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then> <block>{
            <comment type="line">// not a multi-word name</comment>
            <expr_stmt><expr><name>input</name> = <call><name><name>words</name>.<name>iterator</name></name><argument_list>()</argument_list></call>.<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="line">// encode each word in a multi-word name separately (normally used for approx matches)</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>result</name> =<init> <expr>new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>word</name> :<range> <expr><name>words2</name></expr></range></decl></init>) <block>{
                <expr_stmt><expr><call><name><name>result</name>.<name>append</name></name><argument_list>(<argument><expr>"-"</expr></argument>)</argument_list></call>.<call><name>append</name><argument_list>(<argument><expr><call><name>encode</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <comment type="line">// return the result without the leading "-"</comment>
            <return>return <expr><call><name><name>result</name>.<name>substring</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if></else></if>

        <decl_stmt><decl><type><name>PhonemeBuilder</name></type> <name>phonemeBuilder</name> =<init> <expr><call><name><name>PhonemeBuilder</name>.<name>empty</name></name><argument_list>(<argument><expr><name>languageSet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// loop over each char in the input - we will handle the increment manually</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>RulesApplication</name></type> <name>rulesApplication</name> =<init>
                    <expr>new <call><name>RulesApplication</name><argument_list>(<argument><expr><name>rules</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>phonemeBuilder</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>maxPhonemes</name></expr></argument>)</argument_list></call>.<call><name>invoke</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>i</name> = <call><name><name>rulesApplication</name>.<name>getI</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>phonemeBuilder</name> = <call><name><name>rulesApplication</name>.<name>getPhonemeBuilder</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="line">// Apply the general rules</comment>
        <expr_stmt><expr><name>phonemeBuilder</name> = <call><name>applyFinalRules</name><argument_list>(<argument><expr><name>phonemeBuilder</name></expr></argument>, <argument><expr><name>finalRules1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Apply the language-specific rules</comment>
        <expr_stmt><expr><name>phonemeBuilder</name> = <call><name>applyFinalRules</name><argument_list>(<argument><expr><name>phonemeBuilder</name></expr></argument>, <argument><expr><name>finalRules2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><call><name><name>phonemeBuilder</name>.<name>makeString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets the Lang language guessing rules being used.
     *
     * @return the Lang in use
     */</comment>
    <function><type><specifier>public</specifier> <name>Lang</name></type> <name>getLang</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>lang</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets the NameType being used.
     *
     * @return the NameType in use
     */</comment>
    <function><type><specifier>public</specifier> <name>NameType</name></type> <name>getNameType</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>nameType</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets the RuleType being used.
     *
     * @return the RuleType in use
     */</comment>
    <function><type><specifier>public</specifier> <name>RuleType</name></type> <name>getRuleType</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>ruleType</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.
     *
     * @return true if multiple phonetic encodings are returned, false if just the first is
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isConcat</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>concat</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets the maximum number of phonemes the engine will calculate for a given input.
     *
     * @return the maximum number of phonemes
     * @since 1.7
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMaxPhonemes</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>maxPhonemes</name></name></expr>;</return>
    }</block></function>
}</block></class>
</unit>
