<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\David\IdeaProjects\arem\resources\systems\ccodec\src\main\java\org\apache\commons\codec\language\bm\Rule.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>language</name>.<name>bm</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>InputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Arrays</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Collections</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Comparator</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>EnumMap</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashMap</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>HashSet</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Map</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Scanner</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Set</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>regex</name>.<name>Matcher</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>regex</name>.<name>Pattern</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>codec</name>.<name>language</name>.<name>bm</name>.<name>Languages</name>.<name>LanguageSet</name></name>;</import>

<comment type="javadoc">/**
 * A phoneme rule.
 * &lt;p&gt;
 * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply
 * and a logical flag indicating if all languages must be in play. A rule matches if:
 * &lt;ul&gt;
 * &lt;li&gt;the pattern matches at the current position&lt;/li&gt;
 * &lt;li&gt;the string up until the beginning of the pattern matches the left context&lt;/li&gt;
 * &lt;li&gt;the string from the end of the pattern matches the right context&lt;/li&gt;
 * &lt;li&gt;logical is ALL and all languages are in scope; or&lt;/li&gt;
 * &lt;li&gt;logical is any other value and at least one language is in scope&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user
 * to explicitly construct their own.
 * &lt;p&gt;
 * Rules are immutable and thread-safe.
 * &lt;p&gt;
 * &lt;b&gt;Rules resources&lt;/b&gt;
 * &lt;p&gt;
 * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically
 * named following the pattern:
 * &lt;blockquote&gt;org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt&lt;/blockquote&gt;
 * &lt;p&gt;
 * The format of these resources is the following:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;b&gt;Rules:&lt;/b&gt; whitespace separated, double-quoted strings. There should be 4 columns to each row, and these
 * will be interpreted as:
 * &lt;ol&gt;
 * &lt;li&gt;pattern&lt;/li&gt;
 * &lt;li&gt;left context&lt;/li&gt;
 * &lt;li&gt;right context&lt;/li&gt;
 * &lt;li&gt;phoneme&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;End-of-line comments:&lt;/b&gt; Any occurrence of '//' will cause all text following on that line to be discarded
 * as a comment.&lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;Multi-line comments:&lt;/b&gt; Any line starting with '/*' will start multi-line commenting mode. This will skip
 * all content until a line ending in '*' and '/' is found.&lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;Blank lines:&lt;/b&gt; All blank lines will be skipped.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @since 1.6
 * @version $Id: Rule.java 1544532 2013-11-22 13:38:35Z ggregory $
 */</comment>
<class><specifier>public</specifier> class <name>Rule</name> <block>{

    <class><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>Phoneme</name> <super><implements>implements <name>PhonemeExpr</name></implements></super> <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Comparator</name><argument_list>&lt;<argument><name>Phoneme</name></argument>&gt;</argument_list></name></type> <name>COMPARATOR</name> =<init> <expr>new <class><super><name><name>Comparator</name><argument_list>&lt;<argument><name>Phoneme</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
            <function><type><annotation>@<name>Override</name></annotation>
            <specifier>public</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Phoneme</name></type> <name>o1</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>Phoneme</name></type> <name>o2</name></decl></param>)</parameter_list> <block>{
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>o1</name>.<name>phonemeText</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <if>if <condition>(<expr><name>i</name> &gt;= <call><name><name>o2</name>.<name>phonemeText</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <return>return <expr>+1</expr>;</return>
                    }</block></then></if>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>c</name> =<init> <expr><call><name><name>o1</name>.<name>phonemeText</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> - <call><name><name>o2</name>.<name>phonemeText</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>c</name> != 0</expr>)</condition><then> <block>{
                        <return>return <expr><name>c</name></expr>;</return>
                    }</block></then></if>
                }</block></for>

                <if>if <condition>(<expr><call><name><name>o1</name>.<name>phonemeText</name>.<name>length</name></name><argument_list>()</argument_list></call> &lt; <call><name><name>o2</name>.<name>phonemeText</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr>-1</expr>;</return>
                }</block></then></if>

                <return>return <expr>0</expr>;</return>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>StringBuilder</name></type> <name>phonemeText</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Languages</name>.<name>LanguageSet</name></name></type> <name>languages</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>Phoneme</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>phonemeText</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>Languages</name>.<name>LanguageSet</name></name></type> <name>languages</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>phonemeText</name></name> = new <call><name>StringBuilder</name><argument_list>(<argument><expr><name>phonemeText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>languages</name></name> = <name>languages</name></expr>;</expr_stmt>
        }</block></constructor>

        <constructor><specifier>public</specifier> <name>Phoneme</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Phoneme</name></type> <name>phonemeLeft</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>Phoneme</name></type> <name>phonemeRight</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name><name>phonemeLeft</name>.<name>phonemeText</name></name></expr></argument>, <argument><expr><name><name>phonemeLeft</name>.<name>languages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name>.<name>phonemeText</name>.<name>append</name></name><argument_list>(<argument><expr><name><name>phonemeRight</name>.<name>phonemeText</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <constructor><specifier>public</specifier> <name>Phoneme</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Phoneme</name></type> <name>phonemeLeft</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>Phoneme</name></type> <name>phonemeRight</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>Languages</name>.<name>LanguageSet</name></name></type> <name>languages</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name><name>phonemeLeft</name>.<name>phonemeText</name></name></expr></argument>, <argument><expr><name>languages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>this</name>.<name>phonemeText</name>.<name>append</name></name><argument_list>(<argument><expr><name><name>phonemeRight</name>.<name>phonemeText</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>Phoneme</name></type> <name>append</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>str</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>this</name>.<name>phonemeText</name>.<name>append</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>this</name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name><name>Languages</name>.<name>LanguageSet</name></name></type> <name>getLanguages</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>this</name>.<name>languages</name></name></expr>;</return>
        }</block></function>

        <function><type><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name>Phoneme</name></argument>&gt;</argument_list></name></type> <name>getPhonemes</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>CharSequence</name></type> <name>getPhonemeText</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>this</name>.<name>phonemeText</name></name></expr>;</return>
        }</block></function>

        <comment type="javadoc">/**
         * @deprecated since 1.9
         */</comment>
        <function><type><annotation>@<name>Deprecated</name></annotation>
        <specifier>public</specifier> <name>Phoneme</name></type> <name>join</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Phoneme</name></type> <name>right</name></decl></param>)</parameter_list> <block>{
            <return>return <expr>new <call><name>Phoneme</name><argument_list>(<argument><expr><call><name><name>this</name>.<name>phonemeText</name>.<name>toString</name></name><argument_list>()</argument_list></call> + <call><name><name>right</name>.<name>phonemeText</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><call><name><name>this</name>.<name>languages</name>.<name>restrictTo</name></name><argument_list>(<argument><expr><name><name>right</name>.<name>languages</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>

    <class type="interface"><specifier>public</specifier> interface <name>PhonemeExpr</name> <block>{
        <function_decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>Phoneme</name></argument>&gt;</argument_list></name></type> <name>getPhonemes</name><parameter_list>()</parameter_list>;</function_decl>
    }</block></class>

    <class><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>PhonemeList</name> <super><implements>implements <name>PhonemeExpr</name></implements></super> <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Phoneme</name></argument>&gt;</argument_list></name></type> <name>phonemes</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>PhonemeList</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Phoneme</name></argument>&gt;</argument_list></name></type> <name>phonemes</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>this</name>.<name>phonemes</name></name> = <name>phonemes</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Phoneme</name></argument>&gt;</argument_list></name></type> <name>getPhonemes</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><name><name>this</name>.<name>phonemes</name></name></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="javadoc">/**
     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.
     */</comment>
    <class type="interface"><specifier>public</specifier> interface <name>RPattern</name> <block>{
        <function_decl><type><name>boolean</name></type> <name>isMatch</name><parameter_list>(<param><decl><type><name>CharSequence</name></type> <name>input</name></decl></param>)</parameter_list>;</function_decl>
    }</block></class>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>RPattern</name></type> <name>ALL_STRINGS_RMATCHER</name> =<init> <expr>new <class><super><name>RPattern</name></super><argument_list>()</argument_list> <block>{
        <function><type><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <name>boolean</name></type> <name>isMatch</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
            <return>return <expr>true</expr>;</return>
        }</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>ALL</name> =<init> <expr>"ALL"</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>DOUBLE_QUOTE</name> =<init> <expr>"\""</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>HASH_INCLUDE</name> =<init> <expr>"#include"</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>NameType</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>RuleType</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>RULES</name> =<init>
            <expr>new <call><name><name>EnumMap</name><argument_list>&lt;<argument><name>NameType</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>RuleType</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>NameType</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    static <block>{
        <for>for (<init><decl><type><specifier>final</specifier> <name>NameType</name></type> <name>s</name> :<range> <expr><call><name><name>NameType</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>RuleType</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rts</name> =<init>
                    <expr>new <call><name><name>EnumMap</name><argument_list>&lt;<argument><name>RuleType</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>RuleType</name>.<name><name/></name></name>class</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><specifier>final</specifier> <name>RuleType</name></type> <name>rt</name> :<range> <expr><call><name><name>RuleType</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rs</name> =<init> <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><specifier>final</specifier> <name>Languages</name></type> <name>ls</name> =<init> <expr><call><name><name>Languages</name>.<name>getInstance</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>l</name> :<range> <expr><call><name><name>ls</name>.<name>getLanguages</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
                    <try>try <block>{
                        <expr_stmt><expr><call><name><name>rs</name>.<name>put</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>parseRules</name><argument_list>(<argument><expr><call><name>createScanner</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>createResourceName</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block> <catch>catch (<param><decl><type><specifier>final</specifier> <name>IllegalStateException</name></type> <name>e</name></decl></param>) <block>{
                        <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Problem processing " + <call><name>createResourceName</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></catch></try>
                }</block></for>
                <if>if <condition>(<expr>!<call><name><name>rt</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>RuleType</name>.<name>RULES</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>rs</name>.<name>put</name></name><argument_list>(<argument><expr>"common"</expr></argument>, <argument><expr><call><name>parseRules</name><argument_list>(<argument><expr><call><name>createScanner</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr>"common"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>createResourceName</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr>"common"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <expr_stmt><expr><call><name><name>rts</name>.<name>put</name></name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><call><name><name>Collections</name>.<name>unmodifiableMap</name></name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <expr_stmt><expr><call><name><name>RULES</name>.<name>put</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name><name>Collections</name>.<name>unmodifiableMap</name></name><argument_list>(<argument><expr><name>rts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>contains</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>chars</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>char</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>chars</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name><name>chars</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> == <name>input</name></expr>)</condition><then> <block>{
                <return>return <expr>true</expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>createResourceName</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>NameType</name></type> <name>nameType</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>RuleType</name></type> <name>rt</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>lang</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"org/apache/commons/codec/language/bm/%s_%s_%s.txt"</expr></argument>,
                             <argument><expr><call><name><name>nameType</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>rt</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>Scanner</name></type> <name>createScanner</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>NameType</name></type> <name>nameType</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>RuleType</name></type> <name>rt</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>lang</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>resName</name> =<init> <expr><call><name>createResourceName</name><argument_list>(<argument><expr><name>nameType</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>InputStream</name></type> <name>rulesIS</name> =<init> <expr><name><name>Languages</name>.<name><name/></name></name>class.<call><name>getClassLoader</name><argument_list>()</argument_list></call>.<call><name>getResourceAsStream</name><argument_list>(<argument><expr><name>resName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>rulesIS</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Unable to load resource: " + <name>resName</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <return>return <expr>new <call><name>Scanner</name><argument_list>(<argument><expr><name>rulesIS</name></expr></argument>, <argument><expr><name><name>ResourceConstants</name>.<name>ENCODING</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>Scanner</name></type> <name>createScanner</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>lang</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>resName</name> =<init> <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"org/apache/commons/codec/language/bm/%s.txt"</expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>InputStream</name></type> <name>rulesIS</name> =<init> <expr><name><name>Languages</name>.<name><name/></name></name>class.<call><name>getClassLoader</name><argument_list>()</argument_list></call>.<call><name>getResourceAsStream</name><argument_list>(<argument><expr><name>resName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>rulesIS</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Unable to load resource: " + <name>resName</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <return>return <expr>new <call><name>Scanner</name><argument_list>(<argument><expr><name>rulesIS</name></expr></argument>, <argument><expr><name><name>ResourceConstants</name>.<name>ENCODING</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>endsWith</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>suffix</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>suffix</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; <call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr><call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call> - 1</expr></init>, <name>j</name> =<init> <expr><call><name><name>suffix</name>.<name>length</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</init> <condition><expr><name>j</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>j</name>--</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name><name>input</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> != <call><name><name>suffix</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets rules for a combination of name type, rule type and languages.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param langs
     *            the set of languages to consider
     * @return a list of Rules that apply
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></type> <name>getInstance</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>NameType</name></type> <name>nameType</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>RuleType</name></type> <name>rt</name></decl></param>,
                                         <param><decl><type><specifier>final</specifier> <name><name>Languages</name>.<name>LanguageSet</name></name></type> <name>langs</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ruleMap</name> =<init> <expr><call><name>getInstanceMap</name><argument_list>(<argument><expr><name>nameType</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr><name>langs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></type> <name>allRules</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></type> <name>rules</name> :<range> <expr><call><name><name>ruleMap</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>) <block>{
            <expr_stmt><expr><call><name><name>allRules</name>.<name>addAll</name></name><argument_list>(<argument><expr><name>rules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>allRules</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets rules for a combination of name type, rule type and a single language.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param lang
     *            the language to consider
     * @return a list of Rules that apply
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></type> <name>getInstance</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>NameType</name></type> <name>nameType</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>RuleType</name></type> <name>rt</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>lang</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>getInstance</name><argument_list>(<argument><expr><name>nameType</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr><call><name><name>LanguageSet</name>.<name>from</name></name><argument_list>(<argument><expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets rules for a combination of name type, rule type and languages.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param langs
     *            the set of languages to consider
     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern
     * @since 1.9
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getInstanceMap</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>NameType</name></type> <name>nameType</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>RuleType</name></type> <name>rt</name></decl></param>,
                                                         <param><decl><type><specifier>final</specifier> <name><name>Languages</name>.<name>LanguageSet</name></name></type> <name>langs</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>langs</name>.<name>isSingleton</name></name><argument_list>()</argument_list></call> ? <call><name>getInstanceMap</name><argument_list>(<argument><expr><name>nameType</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr><call><name><name>langs</name>.<name>getAny</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> :
                                     <call><name>getInstanceMap</name><argument_list>(<argument><expr><name>nameType</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr><name><name>Languages</name>.<name>ANY</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets rules for a combination of name type, rule type and a single language.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param lang
     *            the language to consider
     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern
     * @since 1.9
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getInstanceMap</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>NameType</name></type> <name>nameType</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>RuleType</name></type> <name>rt</name></decl></param>,
                                                         <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>lang</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rules</name> =<init> <expr><call><name><name>RULES</name>.<name>get</name></name><argument_list>(<argument><expr><name>nameType</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>rules</name> == <name>null</name></expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"No rules found for %s, %s, %s."</expr></argument>,
                                               <argument><expr><call><name><name>nameType</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>rt</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <return>return <expr><name>rules</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>Phoneme</name></type> <name>parsePhoneme</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>ph</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>open</name> =<init> <expr><call><name><name>ph</name>.<name>indexOf</name></name><argument_list>(<argument><expr>"["</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>open</name> &gt;= 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name><name>ph</name>.<name>endsWith</name></name><argument_list>(<argument><expr>"]"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Phoneme expression contains a '[' but does not end in ']'"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>before</name> =<init> <expr><call><name><name>ph</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>open</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>in</name> =<init> <expr><call><name><name>ph</name>.<name>substring</name></name><argument_list>(<argument><expr><name>open</name> + 1</expr></argument>, <argument><expr><call><name><name>ph</name>.<name>length</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>langs</name> =<init> <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><call><name><name>in</name>.<name>split</name></name><argument_list>(<argument><expr>"[+]"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr>new <call><name>Phoneme</name><argument_list>(<argument><expr><name>before</name></expr></argument>, <argument><expr><call><name><name>Languages</name>.<name>LanguageSet</name>.<name>from</name></name><argument_list>(<argument><expr><name>langs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <block>{
            <return>return <expr>new <call><name>Phoneme</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><name><name>Languages</name>.<name>ANY_LANGUAGE</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>PhonemeExpr</name></type> <name>parsePhonemeExpr</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>ph</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>ph</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"("</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// we have a bracketed list of options</comment>
            <if>if <condition>(<expr>!<call><name><name>ph</name>.<name>endsWith</name></name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Phoneme starts with '(' so must end with ')'"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>

            <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Phoneme</name></argument>&gt;</argument_list></name></type> <name>phs</name> =<init> <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Phoneme</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>body</name> =<init> <expr><call><name><name>ph</name>.<name>substring</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name><name>ph</name>.<name>length</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>part</name> :<range> <expr><call><name><name>body</name>.<name>split</name></name><argument_list>(<argument><expr>"[|]"</expr></argument>)</argument_list></call></expr></range></decl></init>) <block>{
                <expr_stmt><expr><call><name><name>phs</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>parsePhoneme</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <if>if <condition>(<expr><call><name><name>body</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"|"</expr></argument>)</argument_list></call> || <call><name><name>body</name>.<name>endsWith</name></name><argument_list>(<argument><expr>"|"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>phs</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>Phoneme</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name><name>Languages</name>.<name>ANY_LANGUAGE</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <return>return <expr>new <call><name>PhonemeList</name><argument_list>(<argument><expr><name>phs</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <block>{
            <return>return <expr><call><name>parsePhoneme</name><argument_list>(<argument><expr><name>ph</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>parseRules</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Scanner</name></type> <name>scanner</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>location</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>lines</name> =<init> <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>currentLine</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>boolean</name></type> <name>inMultilineComment</name> =<init> <expr>false</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>scanner</name>.<name>hasNextLine</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><name>currentLine</name>++</expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>rawLine</name> =<init> <expr><call><name><name>scanner</name>.<name>nextLine</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>line</name> =<init> <expr><name>rawLine</name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>inMultilineComment</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name><name>line</name>.<name>endsWith</name></name><argument_list>(<argument><expr><name><name>ResourceConstants</name>.<name>EXT_CMT_END</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>inMultilineComment</name> = false</expr>;</expr_stmt>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><call><name><name>line</name>.<name>startsWith</name></name><argument_list>(<argument><expr><name><name>ResourceConstants</name>.<name>EXT_CMT_START</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>inMultilineComment</name> = true</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <comment type="line">// discard comments</comment>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>cmtI</name> =<init> <expr><call><name><name>line</name>.<name>indexOf</name></name><argument_list>(<argument><expr><name><name>ResourceConstants</name>.<name>CMT</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>cmtI</name> &gt;= 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>line</name> = <call><name><name>line</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>cmtI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <comment type="line">// trim leading-trailing whitespace</comment>
                    <expr_stmt><expr><name>line</name> = <call><name><name>line</name>.<name>trim</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <if>if <condition>(<expr><call><name><name>line</name>.<name>length</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
                        <continue>continue;</continue> <comment type="line">// empty lines can be safely skipped</comment>
                    }</block></then></if>

                    <if>if <condition>(<expr><call><name><name>line</name>.<name>startsWith</name></name><argument_list>(<argument><expr><name>HASH_INCLUDE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="line">// include statement</comment>
                        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>incl</name> =<init> <expr><call><name><name>line</name>.<name>substring</name></name><argument_list>(<argument><expr><call><name><name>HASH_INCLUDE</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>trim</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name><name>incl</name>.<name>contains</name></name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Malformed import statement '" + <name>rawLine</name> + "' in " +
                                                               <name>location</name></expr></argument>)</argument_list></call></expr>;</throw>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><call><name><name>lines</name>.<name>putAll</name></name><argument_list>(<argument><expr><call><name>parseRules</name><argument_list>(<argument><expr><call><name>createScanner</name><argument_list>(<argument><expr><name>incl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>location</name> + "-&gt;" + <name>incl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>
                    }</block></then> <else>else <block>{
                        <comment type="line">// rule</comment>
                        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name><index>[]</index></type> <name>parts</name> =<init> <expr><call><name><name>line</name>.<name>split</name></name><argument_list>(<argument><expr>"\\s+"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name><name>parts</name>.<name>length</name></name> != 4</expr>)</condition><then> <block>{
                            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Malformed rule statement split into " + <name><name>parts</name>.<name>length</name></name> +
                                                               " parts: " + <name>rawLine</name> + " in " + <name>location</name></expr></argument>)</argument_list></call></expr>;</throw>
                        }</block></then> <else>else <block>{
                            <try>try <block>{
                                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>pat</name> =<init> <expr><call><name>stripQuotes</name><argument_list>(<argument><expr><name><name>parts</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>lCon</name> =<init> <expr><call><name>stripQuotes</name><argument_list>(<argument><expr><name><name>parts</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>rCon</name> =<init> <expr><call><name>stripQuotes</name><argument_list>(<argument><expr><name><name>parts</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><specifier>final</specifier> <name>PhonemeExpr</name></type> <name>ph</name> =<init> <expr><call><name>parsePhonemeExpr</name><argument_list>(<argument><expr><call><name>stripQuotes</name><argument_list>(<argument><expr><name><name>parts</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>cLine</name> =<init> <expr><name>currentLine</name></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><specifier>final</specifier> <name>Rule</name></type> <name>r</name> =<init> <expr>new <class><super><name>Rule</name></super><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>lCon</name></expr></argument>, <argument><expr><name>rCon</name></expr></argument>, <argument><expr><name>ph</name></expr></argument>)</argument_list> <block>{
                                    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>myLine</name> =<init> <expr><name>cLine</name></expr></init></decl>;</decl_stmt>
                                    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>String</name></type> <name>loc</name> =<init> <expr><name>location</name></expr></init></decl>;</decl_stmt>

                                    <function><type><annotation>@<name>Override</name></annotation>
                                    <specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{
                                        <decl_stmt><decl><type><specifier>final</specifier> <name>StringBuilder</name></type> <name>sb</name> =<init> <expr>new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                                        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>"Rule"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>"{line="</expr></argument>)</argument_list></call>.<call><name>append</name><argument_list>(<argument><expr><name>myLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>", loc='"</expr></argument>)</argument_list></call>.<call><name>append</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call>.<call><name>append</name><argument_list>(<argument><expr>'\''</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>'}'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <return>return <expr><call><name><name>sb</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
                                    }</block></function>
                                }</block></class></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>patternKey</name> =<init> <expr><call><name><name>r</name>.<name>pattern</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name></type> <name>rules</name> =<init> <expr><call><name><name>lines</name>.<name>get</name></name><argument_list>(<argument><expr><name>patternKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <if>if <condition>(<expr><name>rules</name> == <name>null</name></expr>)</condition><then> <block>{
                                    <expr_stmt><expr><name>rules</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Rule</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name><name>lines</name>.<name>put</name></name><argument_list>(<argument><expr><name>patternKey</name></expr></argument>, <argument><expr><name>rules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                }</block></then></if>
                                <expr_stmt><expr><call><name><name>rules</name>.<name>add</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block> <catch>catch (<param><decl><type><specifier>final</specifier> <name>IllegalArgumentException</name></type> <name>e</name></decl></param>) <block>{
                                <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Problem parsing line '" + <name>currentLine</name> + "' in " +
                                                                <name>location</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                            }</block></catch></try>
                        }</block></else></if>
                    }</block></else></if>
                }</block></else></if>
            }</block></else></if>
        }</block></while>

        <return>return <expr><name>lines</name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.
     *
     * @param regex
     *            the regular expression to compile
     * @return an RPattern that will match this regex
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>RPattern</name></type> <name>pattern</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>regex</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>startsWith</name> =<init> <expr><call><name><name>regex</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"^"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>endsWith</name> =<init> <expr><call><name><name>regex</name>.<name>endsWith</name></name><argument_list>(<argument><expr>"$"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>content</name> =<init> <expr><call><name><name>regex</name>.<name>substring</name></name><argument_list>(<argument><expr><name>startsWith</name> ? 1 : 0</expr></argument>, <argument><expr><name>endsWith</name> ? <call><name><name>regex</name>.<name>length</name></name><argument_list>()</argument_list></call> - 1 : <call><name><name>regex</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>boxes</name> =<init> <expr><call><name><name>content</name>.<name>contains</name></name><argument_list>(<argument><expr>"["</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<name>boxes</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>startsWith</name> &amp;&amp; <name>endsWith</name></expr>)</condition><then> <block>{
                <comment type="line">// exact match</comment>
                <if>if <condition>(<expr><call><name><name>content</name>.<name>length</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
                    <comment type="line">// empty</comment>
                    <return>return <expr>new <class><super><name>RPattern</name></super><argument_list>()</argument_list> <block>{
                        <function><type><annotation>@<name>Override</name></annotation>
                        <specifier>public</specifier> <name>boolean</name></type> <name>isMatch</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
                            <return>return <expr><call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call> == 0</expr>;</return>
                        }</block></function>
                    }</block></class></expr>;</return>
                }</block></then> <else>else <block>{
                    <return>return <expr>new <class><super><name>RPattern</name></super><argument_list>()</argument_list> <block>{
                        <function><type><annotation>@<name>Override</name></annotation>
                        <specifier>public</specifier> <name>boolean</name></type> <name>isMatch</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
                            <return>return <expr><call><name><name>input</name>.<name>equals</name></name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</return>
                        }</block></function>
                    }</block></class></expr>;</return>
                }</block></else></if>
            }</block></then> <else>else <if>if <condition>(<expr>(<name>startsWith</name> || <name>endsWith</name>) &amp;&amp; <call><name><name>content</name>.<name>length</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
                <comment type="line">// matches every string</comment>
                <return>return <expr><name>ALL_STRINGS_RMATCHER</name></expr>;</return>
            }</block></then> <else>else <if>if <condition>(<expr><name>startsWith</name></expr>)</condition><then> <block>{
                <comment type="line">// matches from start</comment>
                <return>return <expr>new <class><super><name>RPattern</name></super><argument_list>()</argument_list> <block>{
                    <function><type><annotation>@<name>Override</name></annotation>
                    <specifier>public</specifier> <name>boolean</name></type> <name>isMatch</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
                        <return>return <expr><call><name>startsWith</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</return>
                    }</block></function>
                }</block></class></expr>;</return>
            }</block></then> <else>else <if>if <condition>(<expr><name>endsWith</name></expr>)</condition><then> <block>{
                <comment type="line">// matches from start</comment>
                <return>return <expr>new <class><super><name>RPattern</name></super><argument_list>()</argument_list> <block>{
                    <function><type><annotation>@<name>Override</name></annotation>
                    <specifier>public</specifier> <name>boolean</name></type> <name>isMatch</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
                        <return>return <expr><call><name>endsWith</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</return>
                    }</block></function>
                }</block></class></expr>;</return>
            }</block></then></if></else></if></else></if></else></if>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>startsWithBox</name> =<init> <expr><call><name><name>content</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"["</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>endsWithBox</name> =<init> <expr><call><name><name>content</name>.<name>endsWith</name></name><argument_list>(<argument><expr>"]"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>startsWithBox</name> &amp;&amp; <name>endsWithBox</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>boxContent</name> =<init> <expr><call><name><name>content</name>.<name>substring</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name><name>content</name>.<name>length</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<call><name><name>boxContent</name>.<name>contains</name></name><argument_list>(<argument><expr>"["</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="line">// box containing alternatives</comment>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>negate</name> =<init> <expr><call><name><name>boxContent</name>.<name>startsWith</name></name><argument_list>(<argument><expr>"^"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>negate</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>boxContent</name> = <call><name><name>boxContent</name>.<name>substring</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>bContent</name> =<init> <expr><name>boxContent</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>shouldMatch</name> =<init> <expr>!<name>negate</name></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr><name>startsWith</name> &amp;&amp; <name>endsWith</name></expr>)</condition><then> <block>{
                        <comment type="line">// exact match</comment>
                        <return>return <expr>new <class><super><name>RPattern</name></super><argument_list>()</argument_list> <block>{
                            <function><type><annotation>@<name>Override</name></annotation>
                            <specifier>public</specifier> <name>boolean</name></type> <name>isMatch</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
                                <return>return <expr><call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call> == 1 &amp;&amp; <call><name>contains</name><argument_list>(<argument><expr><name>bContent</name></expr></argument>, <argument><expr><call><name><name>input</name>.<name>charAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>shouldMatch</name></expr>;</return>
                            }</block></function>
                        }</block></class></expr>;</return>
                    }</block></then> <else>else <if>if <condition>(<expr><name>startsWith</name></expr>)</condition><then> <block>{
                        <comment type="line">// first char</comment>
                        <return>return <expr>new <class><super><name>RPattern</name></super><argument_list>()</argument_list> <block>{
                            <function><type><annotation>@<name>Override</name></annotation>
                            <specifier>public</specifier> <name>boolean</name></type> <name>isMatch</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
                                <return>return <expr><call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0 &amp;&amp; <call><name>contains</name><argument_list>(<argument><expr><name>bContent</name></expr></argument>, <argument><expr><call><name><name>input</name>.<name>charAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>shouldMatch</name></expr>;</return>
                            }</block></function>
                        }</block></class></expr>;</return>
                    }</block></then> <else>else <if>if <condition>(<expr><name>endsWith</name></expr>)</condition><then> <block>{
                        <comment type="line">// last char</comment>
                        <return>return <expr>new <class><super><name>RPattern</name></super><argument_list>()</argument_list> <block>{
                            <function><type><annotation>@<name>Override</name></annotation>
                            <specifier>public</specifier> <name>boolean</name></type> <name>isMatch</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
                                <return>return <expr><call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0 &amp;&amp;
                                       <call><name>contains</name><argument_list>(<argument><expr><name>bContent</name></expr></argument>, <argument><expr><call><name><name>input</name>.<name>charAt</name></name><argument_list>(<argument><expr><call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>shouldMatch</name></expr>;</return>
                            }</block></function>
                        }</block></class></expr>;</return>
                    }</block></then></if></else></if></else></if>
                }</block></then></if>
            }</block></then></if>
        }</block></else></if>

        <return>return <expr>new <class><super><name>RPattern</name></super><argument_list>()</argument_list> <block>{
            <decl_stmt><decl><type><name>Pattern</name></type> <name>pattern</name> =<init> <expr><call><name><name>Pattern</name>.<name>compile</name></name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <function><type><annotation>@<name>Override</name></annotation>
            <specifier>public</specifier> <name>boolean</name></type> <name>isMatch</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>)</parameter_list> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>Matcher</name></type> <name>matcher</name> =<init> <expr><call><name><name>pattern</name>.<name>matcher</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <return>return <expr><call><name><name>matcher</name>.<name>find</name></name><argument_list>()</argument_list></call></expr>;</return>
            }</block></function>
        }</block></class></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>startsWith</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>prefix</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>prefix</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; <call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>prefix</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name><name>input</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> != <call><name><name>prefix</name>.<name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>stripQuotes</name><parameter_list>(<param><decl><type><name>String</name></type> <name>str</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>str</name>.<name>startsWith</name></name><argument_list>(<argument><expr><name>DOUBLE_QUOTE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>str</name> = <call><name><name>str</name>.<name>substring</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>str</name>.<name>endsWith</name></name><argument_list>(<argument><expr><name>DOUBLE_QUOTE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>str</name> = <call><name><name>str</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>str</name>.<name>length</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr><name>str</name></expr>;</return>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>RPattern</name></type> <name>lContext</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>String</name></type> <name>pattern</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>PhonemeExpr</name></type> <name>phoneme</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>RPattern</name></type> <name>rContext</name></decl>;</decl_stmt>

    <comment type="javadoc">/**
     * Creates a new rule.
     *
     * @param pattern
     *            the pattern
     * @param lContext
     *            the left context
     * @param rContext
     *            the right context
     * @param phoneme
     *            the resulting phoneme
     */</comment>
    <constructor><specifier>public</specifier> <name>Rule</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>pattern</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>lContext</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>rContext</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>PhonemeExpr</name></type> <name>phoneme</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>.<name>pattern</name></name> = <name>pattern</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>lContext</name></name> = <call><name>pattern</name><argument_list>(<argument><expr><name>lContext</name> + "$"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>rContext</name></name> = <call><name>pattern</name><argument_list>(<argument><expr>"^" + <name>rContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>phoneme</name></name> = <name>phoneme</name></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="javadoc">/**
     * Gets the left context. This is a regular expression that must match to the left of the pattern.
     *
     * @return the left context Pattern
     */</comment>
    <function><type><specifier>public</specifier> <name>RPattern</name></type> <name>getLContext</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>lContext</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets the pattern. This is a string-literal that must exactly match.
     *
     * @return the pattern
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getPattern</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>pattern</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.
     *
     * @return the phoneme
     */</comment>
    <function><type><specifier>public</specifier> <name>PhonemeExpr</name></type> <name>getPhoneme</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>phoneme</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Gets the right context. This is a regular expression that must match to the right of the pattern.
     *
     * @return the right context Pattern
     */</comment>
    <function><type><specifier>public</specifier> <name>RPattern</name></type> <name>getRContext</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>this</name>.<name>rContext</name></name></expr>;</return>
    }</block></function>

    <comment type="javadoc">/**
     * Decides if the pattern and context match the input starting at a position. It is a match if the
     * &lt;code&gt;lContext&lt;/code&gt; matches &lt;code&gt;input&lt;/code&gt; up to &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; matches at i and
     * &lt;code&gt;rContext&lt;/code&gt; matches from the end of the match of &lt;code&gt;pattern&lt;/code&gt; to the end of &lt;code&gt;input&lt;/code&gt;.
     *
     * @param input
     *            the input String
     * @param i
     *            the int position within the input
     * @return true if the pattern and left/right context match, false otherwise
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>patternAndContextMatches</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>CharSequence</name></type> <name>input</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>int</name></type> <name>i</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
            <throw>throw <expr>new <call><name>IndexOutOfBoundsException</name><argument_list>(<argument><expr>"Can not match pattern at negative indexes"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>patternLength</name> =<init> <expr><call><name><name>this</name>.<name>pattern</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>ipl</name> =<init> <expr><name>i</name> + <name>patternLength</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>ipl</name> &gt; <call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// not enough room for the pattern to match</comment>
            <return>return <expr>false</expr>;</return>
        }</block></then></if>

        <comment type="line">// evaluate the pattern, left context and right context</comment>
        <comment type="line">// fail early if any of the evaluations is not successful</comment>
        <if>if <condition>(<expr>!<call><name><name>input</name>.<name>subSequence</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>ipl</name></expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name><name>this</name>.<name>pattern</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then> <else>else <if>if <condition>(<expr>!<call><name><name>this</name>.<name>rContext</name>.<name>isMatch</name></name><argument_list>(<argument><expr><call><name><name>input</name>.<name>subSequence</name></name><argument_list>(<argument><expr><name>ipl</name></expr></argument>, <argument><expr><call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if></else></if>
        <return>return <expr><call><name><name>this</name>.<name>lContext</name>.<name>isMatch</name></name><argument_list>(<argument><expr><call><name><name>input</name>.<name>subSequence</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
}</block></class>
</unit>
